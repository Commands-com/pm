<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Commands.com RA PM Dashboard</title>
    <style>
        /* CSS Grid provides optimal 2D layout control for kanban columns with 95%+ browser support
           Verified: Superior to Flexbox alternative for responsive 4-column -> 1-column layout */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: #f8fafc;
            color: #1e293b;
            min-height: 100vh;
        }
        
        .header {
            background: #1e293b;
            color: white;
            padding: 1rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .header-left {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .header h1 {
            font-size: 1.5rem;
            font-weight: 600;
            margin: 0;
        }
        
        .header-filters {
            display: flex;
            gap: 1.5rem;
            align-items: center;
        }
        
        .filter-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .filter-label {
            font-size: 0.875rem;
            font-weight: 500;
            color: #e2e8f0;
            white-space: nowrap;
        }
        
        .filter-select {
            padding: 0.5rem 0.75rem;
            border: 1px solid #475569;
            border-radius: 6px;
            background-color: #334155;
            color: white;
            font-size: 0.875rem;
            min-width: 150px;
        }
        
        .filter-select:focus {
            outline: none;
            border-color: #51a2ff;
            box-shadow: 0 0 0 2px rgba(81, 162, 255, 0.2);
        }
        
        .filter-select option {
            background-color: #334155;
            color: white;
        }

        .delete-filter-btn {
            background: none;
            border: 1px solid #475569;
            border-radius: 6px;
            padding: 0.5rem;
            color: #e2e8f0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            min-width: 36px;
            height: 36px;
        }

        .delete-filter-btn:hover {
            background-color: #dc2626;
            border-color: #dc2626;
            color: white;
            transform: scale(1.05);
        }

        .delete-filter-btn:active {
            transform: scale(0.95);
        }

        .knowledge-btn {
            background: none;
            border: 1px solid #475569;
            color: #e2e8f0;
            padding: 0.5rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: 1rem;
        }

        .knowledge-btn:hover {
            background-color: #3b82f6;
            border-color: #3b82f6;
            color: white;
            transform: translateY(-1px);
        }

        .knowledge-btn:active {
            transform: scale(0.95);
        }

        /* Assumption Insights Modal Styles */
        .assumption-insights-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(2px);
        }
        
        .assumption-insights-modal-content {
            background: white;
            border-radius: 12px;
            width: 95vw;
            max-width: 1200px;
            height: 90vh;
            max-height: 900px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            position: relative;
            overflow: hidden;
            animation: modalSlideIn 0.3s ease-out;
            display: flex;
            flex-direction: column;
        }
        
        .assumption-modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1.5rem;
            border-bottom: 1px solid #e2e8f0;
            background-color: #f8fafc;
            min-height: 80px;
        }
        
        .assumption-modal-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #1e293b;
            margin: 0;
        }
        
        .assumption-modal-subtitle {
            font-size: 0.875rem;
            color: #64748b;
            margin-top: 0.25rem;
        }
        
        .assumption-modal-body {
            flex: 1;
            padding: 2rem;
            overflow-y: auto;
        }
        
        .assumption-filters-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }
        
        .assumption-filter-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .assumption-filter-label {
            font-size: 0.875rem;
            font-weight: 500;
            color: #374151;
        }
        
        .assumption-filter-select {
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            background: white;
            color: #374151;
            font-size: 0.875rem;
        }
        
        .assumption-filter-select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        .date-range-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
        }
        
        .date-input {
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            background: white;
            color: #374151;
            font-size: 0.875rem;
        }
        
        .date-input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        .assumption-kpi-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }
        
        .assumption-kpi-card {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
        }
        
        .kpi-card-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }
        
        .kpi-card-icon {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .kpi-card-icon.success {
            background: #dcfce7;
            color: #16a34a;
        }
        
        .kpi-card-icon.total {
            background: #dbeafe;
            color: #2563eb;
        }
        
        .kpi-card-icon.partial {
            background: #fef3c7;
            color: #d97706;
        }
        
        .kpi-card-title {
            font-size: 0.875rem;
            font-weight: 500;
            color: #64748b;
            margin: 0;
        }
        
        .kpi-card-value {
            font-size: 2rem;
            font-weight: 700;
            color: #1e293b;
            margin: 0;
        }
        
        .kpi-card-subtitle {
            font-size: 0.75rem;
            color: #64748b;
            margin-top: 0.25rem;
        }
        
        .assumption-data-section {
            margin-bottom: 2rem;
        }
        
        .data-section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
        }
        
        .data-section-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: #1e293b;
            margin: 0;
        }
        
        .assumption-data-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
            border: 1px solid #e2e8f0;
        }
        
        .assumption-data-table th {
            background: #f8fafc;
            color: #374151;
            font-weight: 600;
            font-size: 0.875rem;
            padding: 1rem;
            text-align: left;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .assumption-data-table td {
            padding: 1rem;
            border-bottom: 1px solid #f1f5f9;
            font-size: 0.875rem;
            color: #374151;
        }
        
        .assumption-data-table tbody tr:hover {
            background: #f8fafc;
        }
        
        .assumption-data-table tbody tr:last-child td {
            border-bottom: none;
        }
        
        .tag-type-cell {
            font-family: monospace;
            font-weight: 500;
            color: #1e293b;
        }
        
        .success-rate-cell {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .success-rate-badge {
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
        }
        
        .success-rate-badge.high {
            background: #dcfce7;
            color: #166534;
        }
        
        .success-rate-badge.medium {
            background: #fef3c7;
            color: #92400e;
        }
        
        .success-rate-badge.low {
            background: #fee2e2;
            color: #991b1b;
        }
        
        .validation-counts {
            display: flex;
            gap: 0.5rem;
            font-size: 0.75rem;
        }
        
        .count-badge {
            padding: 0.125rem 0.5rem;
            border-radius: 8px;
            font-weight: 500;
        }
        
        .count-badge.validated {
            background: #dcfce7;
            color: #166534;
        }
        
        .count-badge.rejected {
            background: #fee2e2;
            color: #991b1b;
        }
        
        .count-badge.partial {
            background: #fef3c7;
            color: #92400e;
        }
        
        .outcome-badge {
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
        }
        
        .outcome-badge.validated {
            background: #dcfce7;
            color: #166534;
        }
        
        .outcome-badge.rejected {
            background: #fee2e2;
            color: #991b1b;
        }
        
        .outcome-badge.partial {
            background: #fef3c7;
            color: #92400e;
        }
        
        .reason-preview {
            max-width: 300px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            color: #64748b;
        }
        
        .timestamp-cell {
            color: #64748b;
            font-size: 0.8125rem;
        }
        
        .table-row-clickable {
            cursor: pointer;
        }
        
        .table-row-clickable:hover {
            background: #f1f5f9 !important;
        }
        
        .assumption-detail-drawer {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            height: 100vh;
            background: white;
            box-shadow: -4px 0 15px -3px rgba(0, 0, 0, 0.1);
            transition: right 0.3s ease-in-out;
            z-index: 1100;
            overflow-y: auto;
        }
        
        .assumption-detail-drawer.open {
            right: 0;
        }
        
        .drawer-header {
            padding: 1.5rem;
            border-bottom: 1px solid #e2e8f0;
            background: #f8fafc;
        }
        
        .drawer-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: #1e293b;
            margin: 0;
        }
        
        .drawer-subtitle {
            font-size: 0.875rem;
            color: #64748b;
            margin-top: 0.25rem;
        }
        
        .drawer-close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #64748b;
            cursor: pointer;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
        }
        
        .drawer-close-btn:hover {
            background: #f1f5f9;
            color: #374151;
        }
        
        .drawer-body {
            padding: 1.5rem;
        }
        
        .drawer-section {
            margin-bottom: 2rem;
        }
        
        .drawer-section-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: #374151;
            margin-bottom: 1rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .assumption-empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 4rem 2rem;
            text-align: center;
            color: #64748b;
        }
        
        .empty-state-icon {
            width: 64px;
            height: 64px;
            margin-bottom: 1rem;
            opacity: 0.5;
        }
        
        .empty-state-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #374151;
            margin-bottom: 0.5rem;
        }
        
        .empty-state-message {
            font-size: 0.875rem;
            line-height: 1.5;
            max-width: 400px;
        }
        
        .assumption-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 3rem;
            color: #64748b;
        }
        
        .assumption-loading .spinner {
            width: 32px;
            height: 32px;
            margin-bottom: 1rem;
        }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            .assumption-insights-modal-content {
                width: 98vw;
                height: 95vh;
                margin: 1rem;
            }
            
            .assumption-modal-header {
                padding: 1rem;
                flex-direction: column;
                align-items: stretch;
                gap: 1rem;
            }
            
            .assumption-modal-body {
                padding: 1rem;
            }
            
            .assumption-filters-section {
                grid-template-columns: 1fr;
                gap: 1rem;
            }
            
            .assumption-kpi-cards {
                grid-template-columns: 1fr;
            }
            
            .assumption-data-table {
                font-size: 0.8125rem;
            }
            
            .assumption-data-table th,
            .assumption-data-table td {
                padding: 0.75rem 0.5rem;
            }
            
            .assumption-detail-drawer {
                width: 100vw;
                right: -100vw;
            }
            
            .date-range-inputs {
                grid-template-columns: 1fr;
            }
        }

        /* Delete Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(2px);
        }

        .delete-modal-content {
            background: white;
            border-radius: 12px;
            width: 90vw;
            max-width: 480px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            animation: modalSlideIn 0.3s ease-out;
        }

        .modal-body {
            padding: 2rem;
            display: flex;
            align-items: center;
            gap: 1.5rem;
        }

        .warning-icon {
            flex-shrink: 0;
        }

        .delete-modal-text {
            flex: 1;
        }

        .delete-message {
            font-size: 1.125rem;
            font-weight: 600;
            color: #1f2937;
            margin: 0 0 0.75rem 0;
        }

        .cascade-warning {
            color: #6b7280;
            font-size: 0.875rem;
            margin: 0;
            line-height: 1.4;
        }

        .modal-footer {
            padding: 1rem 2rem 2rem 2rem;
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end;
        }

        .modal-btn {
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-weight: 600;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }

        .modal-btn-cancel {
            background: #f3f4f6;
            color: #374151;
            border-color: #d1d5db;
        }

        .modal-btn-cancel:hover {
            background: #e5e7eb;
            border-color: #9ca3af;
        }

        .modal-btn-danger {
            background: #dc2626;
            color: white;
            border-color: #dc2626;
        }

        .modal-btn-danger:hover {
            background: #b91c1c;
            border-color: #b91c1c;
            transform: translateY(-1px);
            box-shadow: 0 4px 6px -1px rgba(220, 38, 38, 0.3);
        }

        .modal-btn-danger:active {
            transform: translateY(0);
        }

        @keyframes modalSlideIn {
            from {
                transform: scale(0.95) translateY(-10px);
                opacity: 0;
            }
            to {
                transform: scale(1) translateY(0);
                opacity: 1;
            }
        }
        
        /* #COMPLETION_DRIVE_UI: Connection status indicator for WebSocket health monitoring
           Assumption: Color coding provides clear visual feedback for connection state */
        .connection-status {
            display: inline-block;
            margin-left: 1rem;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .connection-status.connected {
            background-color: rgba(34, 197, 94, 0.15);
            color: #16a34a;
            border: 1px solid rgba(34, 197, 94, 0.3);
        }
        
        .connection-status.disconnected {
            background-color: rgba(239, 68, 68, 0.15);
            color: #dc2626;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }
        
        .connection-status.connecting {
            background-color: rgba(245, 158, 11, 0.15);
            color: #d97706;
            border: 1px solid rgba(245, 158, 11, 0.3);
        }
        
        .board {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
            padding: 1rem;
            min-height: calc(100vh - 80px);
        }
        
        /* #COMPLETION_DRIVE_RESPONSIVE: CSS Grid with responsive breakpoints
           Tablet/mobile: Single column layout for better usability on smaller screens */
        @media (max-width: 768px) {
            .board {
                grid-template-columns: 1fr;
                gap: 0.5rem;
                padding: 0.5rem;
            }
        }
        
        .column {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            display: flex;
            flex-direction: column;
            min-height: 500px;
            border: 1px solid rgba(226, 232, 240, 0.8);
        }
        
        .column-header {
            padding: 1rem;
            border-bottom: 1px solid #e2e8f0;
            background-color: #f8fafc;
            border-radius: 12px 12px 0 0;
        }
        
        .column-title {
            font-size: 1.1rem;
            font-weight: 700;
            color: #1e293b;
            margin-bottom: 0.25rem;
            letter-spacing: 0.025em;
        }
        
        .task-count {
            font-size: 0.875rem;
            color: #64748b;
        }

        .column-title-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.25rem;
        }

        .toggle-btn {
            background: none;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            padding: 0.25rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            color: #64748b;
        }

        .toggle-btn:hover {
            background-color: #f1f5f9;
            color: #374151;
            border-color: #9ca3af;
        }

        .toggle-btn:active {
            background-color: #e2e8f0;
        }
        
        /* #COMPLETION_DRIVE_DRAGDROP: Visual feedback for drag operations
           Assumption: Opacity and highlight effects provide clear user feedback */
        .tasks {
            flex: 1;
            padding: 1rem;
            min-height: 400px;
            position: relative;
        }
        
        .tasks.drag-over {
            background-color: #edf2f7;
            border: 2px dashed #a0aec0;
            border-radius: 4px;
        }
        
        .task-card {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 0.875rem;
            margin-bottom: 0.75rem;
            cursor: pointer; /* Changed from move to pointer for modal interaction */
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
        }
        
        .task-card:hover {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            transform: translateY(-2px);
            border-color: #3b82f6;
        }
        
        .task-card.dragging {
            opacity: 0.5;
            transform: rotate(3deg);
        }
        
        /* #SUGGEST_ACCESSIBILITY: Consider adding focus indicators for keyboard navigation
           Current implementation focuses on mouse/touch interactions */
        .task-card.locked {
            border-left: 4px solid #ef4444;
            background-color: #fef2f2;
            cursor: not-allowed;
        }

        .task-actions {
            position: absolute;
            bottom: 0.5rem;
            right: 0.5rem;
            display: flex;
            gap: 0.25rem;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .task-card:hover .task-actions {
            opacity: 1;
        }

        .task-action-btn {
            background: none;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            padding: 0.25rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            color: #6b7280;
            width: 28px;
            height: 28px;
        }

        .task-action-btn:hover {
            background-color: #f3f4f6;
            color: #374151;
            border-color: #9ca3af;
        }

        .move-task-btn:hover {
            background-color: #dbeafe;
            color: #1d4ed8;
            border-color: #3b82f6;
        }

        .delete-task-btn:hover {
            background-color: #fee2e2;
            color: #dc2626;
            border-color: #ef4444;
        }

        .task-action-btn:active {
            transform: scale(0.95);
        }
        
        /* #COMPLETION_DRIVE_RA: RA indicator styles for complexity scoring and mode display
           Assumption: Color coding follows accessibility guidelines and provides clear visual hierarchy */
        .complexity-badge {
            display: inline-block;
            padding: 0.125rem 0.5rem;
            border-radius: 12px;
            font-weight: bold;
            font-size: 0.75rem;
            line-height: 1.2;
            margin-right: 0.5rem;
        }

        .score-1-3 { background-color: #10b981; color: white; } /* Green - Simple */
        .score-4-6 { background-color: #f59e0b; color: white; } /* Yellow - Standard */  
        .score-7-8 { background-color: #ef4444; color: white; } /* Red - RA-Light */
        .score-9-10 { background-color: #7c3aed; color: white; } /* Purple - RA-Full */

        .mode-badge {
            display: inline-block;
            font-size: 0.65rem;
            padding: 2px 6px;
            border-radius: 8px;
            text-transform: uppercase;
            font-weight: 500;
            letter-spacing: 0.025em;
        }

        .mode-badge.simple { background-color: #dcfce7; color: #166534; }
        .mode-badge.standard { background-color: #fef3c7; color: #92400e; }
        .mode-badge.ra-light { background-color: #fecaca; color: #991b1b; }
        .mode-badge.ra-full { background-color: #e9d5ff; color: #6b21a8; }

        /* #COMPLETION_DRIVE_RA: RA tag summary and project context indicators
           Assumption: Compact display maintains card readability while showing essential RA context */
        .ra-tags-summary {
            font-size: 0.7rem;
            color: #64748b;
            margin: 0.25rem 0;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .ra-tag-count {
            background-color: #f1f5f9;
            padding: 0.125rem 0.375rem;
            border-radius: 6px;
            font-weight: 500;
        }

        .project-breadcrumb {
            font-size: 0.7rem;
            color: #64748b;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
        }

        .breadcrumb-separator {
            margin: 0 0.25rem;
            color: #cbd5e1;
        }

        .dependencies-count {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.65rem;
            color: #6366f1;
            background-color: #eef2ff;
            padding: 0.125rem 0.375rem;
            border-radius: 6px;
            font-weight: 500;
        }

        .verification-status {
            display: inline-block;
            font-size: 0.65rem;
            padding: 0.125rem 0.375rem;
            border-radius: 6px;
            font-weight: 500;
            text-transform: uppercase;
        }

        .verification-status.pending { background-color: #fef3c7; color: #92400e; }
        .verification-status.in_progress { background-color: #dbeafe; color: #1e40af; }
        .verification-status.review { background-color: #fecaca; color: #991b1b; }
        .verification-status.done { background-color: #dcfce7; color: #166534; }

        /* #COMPLETION_DRIVE_UX: Adaptive scoring display for predicted vs actual complexity
           Assumption: Side-by-side display makes comparison clear without overwhelming card */
        .adaptive-scoring {
            font-size: 0.7rem;
            color: #64748b;
            margin: 0.25rem 0;
        }

        .score-comparison {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
        }

        .score-arrow {
            color: #cbd5e1;
        }

        .task-indicators {
            display: flex;
            flex-wrap: wrap;
            gap: 0.375rem;
            align-items: center;
            margin: 0.5rem 0 0.25rem 0;
        }

        .task-title {
            font-weight: 600;
            color: #1e293b;
            margin-bottom: 0.5rem;
            line-height: 1.3;
            font-size: 0.925rem;
        }
        
        .task-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.75rem;
            color: #64748b;
            margin-top: 0.5rem;
        }
        
        .task-agent {
            background-color: #f0f9ff;
            color: #0369a1;
            padding: 0.25rem 0.5rem;
            border-radius: 6px;
            font-weight: 500;
            font-size: 0.6875rem;
            letter-spacing: 0.025em;
        }
        
        .task-locked-info {
            background-color: #fef2f2;
            color: #dc2626;
            padding: 0.25rem 0.5rem;
            border-radius: 6px;
            font-weight: 500;
            font-size: 0.6875rem;
            letter-spacing: 0.025em;
        }
        
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 1rem 1.5rem;
            border-radius: 6px;
            color: white;
            font-weight: 500;
            z-index: 1000;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }
        
        .notification.show {
            transform: translateX(0);
        }
        
        .notification.error {
            background-color: #ef4444;
        }
        
        .notification.success {
            background-color: #22c55e;
        }
        
        .notification.info {
            background-color: #3b82f6;
        }
        
        /* #COMPLETION_DRIVE_PERFORMANCE: Loading states for better user experience
           Assumption: Visual feedback during API operations improves perceived performance */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #64748b;
            font-size: 0.875rem;
            font-weight: 500;
        }
        
        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #e2e8f0;
            border-radius: 50%;
            border-top-color: #3b82f6;
            animation: spin 0.8s linear infinite;
            margin-right: 0.5rem;
        }
        
        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
        
        /* #COMPLETION_DRIVE_MODAL: Modal styling with responsive design and accessibility
           Assumption: Modal follows Material Design principles with proper z-index layering */
        .task-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(2px);
        }
        
        .task-modal-content {
            background: white;
            border-radius: 12px;
            width: 90vw;
            max-width: 1000px;
            height: 80vh;
            max-height: 800px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            position: relative;
            overflow: hidden;
        }
        
        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1.25rem 1.5rem;
            border-bottom: 1px solid #e5e5e5;
            background-color: #f8fafc;
        }
        
        .modal-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #1e293b;
            margin: 0;
            flex: 1;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .modal-close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #64748b;
            padding: 0.25rem;
            border-radius: 4px;
            transition: all 0.2s ease;
            line-height: 1;
            min-width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-close-btn:hover {
            background-color: #f1f5f9;
            color: #374151;
        }
        
        /* #COMPLETION_DRIVE_TABS: Tab navigation with visual state indicators
           Assumption: Active tab indicator provides clear visual feedback */
        .modal-tabs {
            display: flex;
            border-bottom: 2px solid #e5e5e5;
            background-color: white;
            overflow-x: auto;
        }
        
        .modal-tab {
            padding: 12px 20px;
            cursor: pointer;
            border: none;
            background: none;
            border-bottom: 3px solid transparent;
            font-weight: 500;
            color: #64748b;
            font-size: 0.875rem;
            transition: all 0.2s ease;
            white-space: nowrap;
            flex-shrink: 0;
        }
        
        .modal-tab:hover {
            color: #374151;
            background-color: #f8fafc;
        }
        
        .modal-tab.active {
            border-bottom-color: #3b82f6;
            color: #3b82f6;
            background-color: #eff6ff;
        }
        
        .modal-content-area {
            flex: 1;
            overflow: hidden;
            position: relative;
        }
        
        /* #COMPLETION_DRIVE_TABS: Tab content with consistent spacing and scrollable areas
           Assumption: Each tab needs its own scrolling behavior */
        .tab-content {
            display: none;
            height: 100%;
            overflow-y: auto;
            padding: 1.5rem;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* Overview Tab Styles */
        .overview-sections {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 2rem;
            height: fit-content;
        }
        
        .task-description {
            background: #f8fafc;
            padding: 1.25rem;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            margin-bottom: 1.5rem;
            line-height: 1.6;
        }
        
        .task-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }
        
        .metric-card {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 1rem;
            text-align: center;
        }
        
        .metric-label {
            font-size: 0.75rem;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
        }
        
        .metric-value {
            font-size: 1.5rem;
            font-weight: 600;
            color: #1e293b;
        }
        
        .overview-sidebar {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        
        .task-breadcrumb-full {
            background: #f1f5f9;
            padding: 1rem;
            border-radius: 8px;
            border-left: 4px solid #3b82f6;
            font-size: 0.875rem;
        }
        
        .task-timestamps {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 1rem;
        }
        
        .timestamp-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
        }
        
        .timestamp-label {
            color: #64748b;
            font-weight: 500;
        }
        
        .timestamp-value {
            color: #1e293b;
        }
        
        .task-status-info {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 1rem;
        }
        
        /* RA Tags Tab Styles */
        .ra-tags-header {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }
        
        .tags-search-input {
            flex: 1;
            min-width: 200px;
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 0.875rem;
        }
        
        .tags-search-input:focus {
            outline: none;
            border-color: #3b82f6;
            ring: 2px solid rgba(59, 130, 246, 0.1);
        }
        
        .tags-category-filter {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        
        .category-filter-btn {
            padding: 0.5rem 1rem;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            font-size: 0.75rem;
            text-transform: uppercase;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        
        .category-filter-btn.active {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }
        
        /* RA Validation Summary Styles */
        .ra-validation-summary {
            margin-bottom: 1.5rem;
        }
        
        .ra-validation-summary h4 {
            font-size: 1rem;
            font-weight: 600;
            color: #374151;
            margin-bottom: 0.75rem;
        }
        
        .ra-stats {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .ra-stats-item {
            display: inline-flex;
            align-items: center;
            padding: 0.375rem 0.75rem;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 500;
            text-transform: capitalize;
            border: 1px solid;
            transition: all 0.2s ease;
        }
        
        .ra-stats-item.validated {
            background: #dcfce7;
            color: #166534;
            border-color: #bbf7d0;
        }
        
        .ra-stats-item.partial {
            background: #fef3c7;
            color: #92400e;
            border-color: #fde68a;
        }
        
        .ra-stats-item.rejected {
            background: #fee2e2;
            color: #991b1b;
            border-color: #fecaca;
        }
        
        .ra-stats-item.pending {
            background: #f1f5f9;
            color: #64748b;
            border-color: #e2e8f0;
        }
        
        .ra-tags-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .ra-tag-category {
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .ra-tag-category-header {
            background: #f8fafc;
            padding: 1rem;
            font-weight: 600;
            color: #1e293b;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .ra-tag-list {
            padding: 1rem;
        }
        
        .ra-tag-item {
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 0.875rem;
            margin-bottom: 0.75rem;
        }
        
        .ra-tag-name {
            font-weight: 600;
            color: #1e293b;
            font-size: 0.875rem;
            margin-bottom: 0.5rem;
            font-family: 'Monaco', 'Menlo', monospace;
        }
        
        .ra-tag-description {
            color: #64748b;
            font-size: 0.875rem;
            line-height: 1.5;
        }
        
        /* RA Tag Context Styles */
        .ra-tag-context {
            margin-top: 0.75rem;
            padding: 0.75rem;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            font-size: 0.75rem;
        }
        
        .context-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.25rem;
            color: #64748b;
        }
        
        .context-item:last-child {
            margin-bottom: 0;
        }
        
        .context-label {
            font-weight: 500;
            min-width: 4rem;
            color: #475569;
        }
        
        .context-value {
            font-family: 'Monaco', 'Menlo', monospace;
            color: #1e293b;
        }
        
        .context-value.file-path {
            color: #0369a1;
        }
        
        .context-value.git-info {
            color: #059669;
        }
        
        .code-snippet {
            margin-top: 0.5rem;
            padding: 0.5rem;
            background: white;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.75rem;
            color: #374151;
            white-space: pre-wrap;
            overflow-x: auto;
        }
        
        /* Enhanced validation details styles */
        .validation-details {
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid #f1f5f9;
        }
        
        .validation-summary {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }
        
        .validation-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .validation-label {
            font-size: 0.75rem;
            font-weight: 500;
            color: #6b7280;
            min-width: 5rem;
        }
        
        .confidence-badge {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            padding: 0.125rem 0.5rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
        }
        
        .validator-name {
            background: #f3f4f6;
            color: #374151;
            padding: 0.125rem 0.5rem;
            border-radius: 6px;
            font-size: 0.75rem;
            font-family: 'Monaco', 'Menlo', monospace;
        }
        
        .validation-date {
            color: #6b7280;
            font-size: 0.75rem;
        }
        
        .validation-reasoning {
            margin-top: 0.5rem;
        }
        
        .reason-label {
            font-size: 0.75rem;
            font-weight: 600;
            color: #374151;
            margin-bottom: 0.375rem;
        }
        
        .reason-text {
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 0.75rem;
            font-size: 0.875rem;
            line-height: 1.5;
            color: #374151;
        }
        
        .reason-text.pending-text {
            background: #fafafa;
            color: #9ca3af;
            text-align: center;
            font-style: italic;
        }
        
        /* Validation status badges */
        .validation-status-badge {
            display: inline-flex;
            align-items: center;
            padding: 0.375rem 0.75rem;
            border-radius: 16px;
            font-size: 0.75rem;
            font-weight: 600;
            gap: 0.25rem;
            border: 1px solid;
        }
        
        .validation-status-badge.validated {
            background: linear-gradient(135deg, #dcfce7, #bbf7d0);
            border-color: #16a34a;
            color: #15803d;
        }
        
        .validation-status-badge.rejected {
            background: linear-gradient(135deg, #fee2e2, #fecaca);
            border-color: #dc2626;
            color: #dc2626;
        }
        
        .validation-status-badge.partial {
            background: linear-gradient(135deg, #fef3c7, #fde68a);
            border-color: #d97706;
            color: #92400e;
        }
        
        .validation-status-badge.pending {
            background: linear-gradient(135deg, #f3f4f6, #e5e7eb);
            border-color: #9ca3af;
            color: #6b7280;
        }
        
        /* Execution Log Tab Styles */
        .log-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
            gap: 1rem;
        }
        
        .log-filters {
            display: flex;
            gap: 1rem;
            align-items: center;
        }
        
        .log-filter-select {
            padding: 0.5rem 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 0.875rem;
            background: white;
        }
        
        .log-refresh-btn {
            padding: 0.5rem 1rem;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875rem;
            transition: background-color 0.2s ease;
        }
        
        .log-refresh-btn:hover {
            background: #2563eb;
        }
        
        .log-pagination {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        
        .pagination-btn {
            padding: 0.25rem 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            font-size: 0.75rem;
        }
        
        .pagination-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .execution-log-container {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        
        .log-entry {
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 1rem;
            border-left: 4px solid #e5e7eb;
        }
        
        .log-entry.prompt {
            border-left-color: #3b82f6;
        }
        
        .log-entry.ra_tag {
            border-left-color: #f59e0b;
        }
        
        .log-entry.status {
            border-left-color: #10b981;
        }
        
        .log-entry.update {
            border-left-color: #8b5cf6;
        }
        
        .log-entry-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        
        .log-entry-type {
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            text-transform: uppercase;
            font-weight: 600;
            letter-spacing: 0.025em;
        }
        
        .log-entry-type.prompt {
            background: #dbeafe;
            color: #1e40af;
        }
        
        .log-entry-type.ra_tag {
            background: #fef3c7;
            color: #92400e;
        }
        
        .log-entry-type.status {
            background: #d1fae5;
            color: #065f46;
        }
        
        .log-entry-type.update {
            background: #e9d5ff;
            color: #6b21a8;
        }
        
        .log-entry-timestamp {
            font-size: 0.75rem;
            color: #64748b;
        }
        
        .log-entry-content {
            font-size: 0.875rem;
            line-height: 1.5;
            color: #374151;
        }
        
        /* System Prompt Tab Styles */
        .prompt-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }
        
        .prompt-version {
            font-size: 0.875rem;
            color: #64748b;
            font-weight: 500;
        }
        
        .prompt-copy-btn {
            padding: 0.5rem 1rem;
            background: #6b7280;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875rem;
            transition: background-color 0.2s ease;
        }
        
        .prompt-copy-btn:hover {
            background: #4b5563;
        }
        
        .system-prompt-container {
            background: #1e293b;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .system-prompt-content {
            color: #e2e8f0;
            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
            font-size: 0.8125rem;
            line-height: 1.5;
            padding: 1.25rem;
            margin: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 400px;
            overflow-y: auto;
        }
        
        /* Dependencies Tab Styles */
        .dependency-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .dependency-stat {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 1rem;
            text-align: center;
        }
        
        .dependencies-container {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        
        .dependency-item {
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .dependency-item:hover {
            border-color: #3b82f6;
            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.1);
        }
        
        .dependency-info {
            flex: 1;
        }
        
        .dependency-name {
            font-weight: 600;
            color: #1e293b;
            margin-bottom: 0.25rem;
        }
        
        .dependency-id {
            font-size: 0.75rem;
            color: #64748b;
        }
        
        .dependency-status {
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 500;
            text-transform: uppercase;
        }
        
        .dependency-status.todo {
            background: #fef3c7;
            color: #92400e;
        }
        
        .dependency-status.in_progress {
            background: #dbeafe;
            color: #1e40af;
        }
        
        .dependency-status.review {
            background: #fecaca;
            color: #991b1b;
        }
        
        .dependency-status.done {
            background: #dcfce7;
            color: #166534;
        }
        
        /* Loading State */
        .modal-loading {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }
        
        .modal-loading .spinner {
            width: 32px;
            height: 32px;
            margin-bottom: 1rem;
        }
        
        /* Knowledge Management Modal Styles */
        .knowledge-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(2px);
        }
        
        .knowledge-modal-content {
            background: white;
            border-radius: 12px;
            width: 90vw;
            max-width: 800px;
            max-height: 80vh;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            position: relative;
            overflow: hidden;
            animation: modalSlideIn 0.3s ease-out;
        }

        .knowledge-modal-body {
            padding: 2rem;
            max-height: calc(80vh - 100px);
            overflow-y: auto;
        }

        .knowledge-section {
            margin-bottom: 2rem;
        }

        .knowledge-section h3 {
            color: #1e293b;
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1rem;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 0.5rem;
        }

        .knowledge-item {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            transition: all 0.2s ease;
        }

        .knowledge-item:hover {
            background: #f1f5f9;
            border-color: #cbd5e1;
        }

        .knowledge-item-title {
            font-weight: 600;
            color: #1e293b;
            margin-bottom: 0.5rem;
        }

        .knowledge-item-description {
            color: #64748b;
            font-size: 0.875rem;
            line-height: 1.5;
        }

        .knowledge-item-tags {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.75rem;
            flex-wrap: wrap;
        }

        .knowledge-tag {
            background: #dbeafe;
            color: #1e40af;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        /* Knowledge Logs Expandable Section Styles */
        .knowledge-logs-section {
            margin-top: 1rem;
            border-top: 1px solid #e2e8f0;
            padding-top: 0.75rem;
        }

        .logs-toggle-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: none;
            border: none;
            color: #64748b;
            font-size: 0.875rem;
            cursor: pointer;
            padding: 0.5rem 0;
            transition: color 0.2s ease;
        }

        .logs-toggle-btn:hover {
            color: #475569;
        }

        .logs-toggle-btn svg {
            transition: transform 0.2s ease;
        }

        .logs-toggle-btn.expanded svg {
            transform: rotate(90deg);
        }

        .knowledge-logs-container {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .knowledge-logs-container.expanded {
            max-height: 400px;
        }

        .knowledge-log-entry {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
        }

        .knowledge-log-entry:last-child {
            margin-bottom: 0;
        }

        .knowledge-log-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .knowledge-log-type {
            background: #e0e7ff;
            color: #3730a3;
            padding: 0.125rem 0.375rem;
            border-radius: 3px;
            font-size: 0.75rem;
            font-weight: 500;
            text-transform: capitalize;
        }

        .knowledge-log-timestamp {
            color: #64748b;
            font-size: 0.75rem;
        }

        .knowledge-log-content {
            color: #374151;
            line-height: 1.4;
        }

        .knowledge-log-user {
            color: #6b7280;
            font-size: 0.75rem;
            margin-top: 0.25rem;
        }

        .logs-loading {
            text-align: center;
            color: #64748b;
            padding: 1rem 0;
            font-size: 0.875rem;
        }

        .logs-empty {
            text-align: center;
            color: #9ca3af;
            padding: 1rem 0;
            font-size: 0.875rem;
            font-style: italic;
        }
        
        /* Interactive Knowledge Management Styles */
        .modal-header {
            background: #f8fafc;
            border-bottom: 1px solid #e2e8f0;
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-height: 60px;
        }
        
        .modal-header-left {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .modal-header-actions {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .context-indicator {
            background: #3b82f6;
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 500;
        }
        
        .action-btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.625rem 1rem;
            border: none;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
        }
        
        .add-btn {
            background: #10b981;
            color: white;
        }
        
        .add-btn:hover {
            background: #059669;
            transform: translateY(-1px);
        }
        
        .save-btn {
            background: #3b82f6;
            color: white;
        }
        
        .save-btn:hover {
            background: #2563eb;
            transform: translateY(-1px);
        }
        
        .save-btn:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
        }
        
        .cancel-btn {
            background: #6b7280;
            color: white;
        }
        
        .cancel-btn:hover {
            background: #4b5563;
            transform: translateY(-1px);
        }
        
        .knowledge-search-container {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
            align-items: center;
        }
        
        .search-input-wrapper {
            position: relative;
            flex: 1;
            max-width: 400px;
        }
        
        .search-icon {
            position: absolute;
            left: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            color: #6b7280;
            pointer-events: none;
        }
        
        .search-input {
            width: 100%;
            padding: 0.75rem 0.75rem 0.75rem 2.5rem;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 0.875rem;
            transition: all 0.2s ease;
        }
        
        .search-input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        .clear-search-btn {
            position: absolute;
            right: 0.5rem;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: #6b7280;
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 4px;
        }
        
        .clear-search-btn:hover {
            background: #f3f4f6;
            color: #374151;
        }
        
        .category-filter {
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 0.875rem;
            background: white;
            min-width: 180px;
        }
        
        .category-filter:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        .knowledge-edit-form {
            background: #f8fafc;
            border: 2px solid #3b82f6;
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            animation: formSlideDown 0.3s ease-out;
        }
        
        @keyframes formSlideDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .form-header h3 {
            color: #1e293b;
            font-size: 1.125rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
        }
        
        .form-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }
        
        .form-group {
            display: flex;
            flex-direction: column;
        }
        
        .form-group.full-width {
            grid-column: 1 / -1;
        }
        
        .form-group label {
            font-size: 0.875rem;
            font-weight: 500;
            color: #374151;
            margin-bottom: 0.5rem;
        }
        
        .form-input, .form-select, .form-textarea {
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 0.875rem;
            transition: all 0.2s ease;
        }
        
        .form-input:focus, .form-select:focus, .form-textarea:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        .form-textarea {
            resize: vertical;
            min-height: 100px;
        }
        
        .textarea-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 0.5rem;
        }
        
        .char-counter {
            font-size: 0.75rem;
            color: #6b7280;
        }
        
        .field-error {
            color: #dc2626;
            font-size: 0.75rem;
            margin-top: 0.25rem;
        }
        
        .field-help {
            color: #6b7280;
            font-size: 0.75rem;
            margin-top: 0.25rem;
        }
        
        .tags-input-container {
            position: relative;
        }
        
        .tags-display {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.75rem;
            min-height: 20px;
        }
        
        .tag-item {
            background: #dbeafe;
            color: #1e40af;
            padding: 0.25rem 0.75rem;
            border-radius: 16px;
            font-size: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .tag-remove {
            background: none;
            border: none;
            color: #1e40af;
            cursor: pointer;
            padding: 0;
            font-size: 0.875rem;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .tag-remove:hover {
            background: #bfdbfe;
        }
        
        .knowledge-item {
            position: relative;
        }
        
        .knowledge-item:hover .item-actions {
            opacity: 1;
            transform: translateX(0);
        }
        
        .item-actions {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            display: flex;
            gap: 0.5rem;
            opacity: 0;
            transform: translateX(10px);
            transition: all 0.2s ease;
        }
        
        .item-action-btn {
            width: 28px;
            height: 28px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            transition: all 0.2s ease;
        }
        
        .edit-btn {
            background: #3b82f6;
            color: white;
        }
        
        .edit-btn:hover {
            background: #2563eb;
            transform: scale(1.1);
        }
        
        .delete-btn {
            background: #dc2626;
            color: white;
        }
        
        .delete-btn:hover {
            background: #b91c1c;
            transform: scale(1.1);
        }
        
        .loading-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 3rem;
            color: #6b7280;
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #f3f4f6;
            border-top: 3px solid #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 1rem;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Inline editing styles */
        .inline-edit-item {
            border: 2px solid #3b82f6;
            background: #eff6ff;
            animation: highlightEdit 0.3s ease-out;
        }
        
        @keyframes highlightEdit {
            from {
                box-shadow: 0 0 20px rgba(59, 130, 246, 0.3);
            }
            to {
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            }
        }
        
        .inline-edit-form {
            padding: 1rem;
        }
        
        .inline-form-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #d1d5db;
        }
        
        .inline-form-header h4 {
            margin: 0;
            color: #1f2937;
            font-size: 1.1rem;
        }
        
        .inline-form-actions {
            display: flex;
            gap: 0.5rem;
        }
        
        .inline-action-btn {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.375rem 0.75rem;
            font-size: 0.75rem;
            border-radius: 4px;
            border: 1px solid;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .inline-action-btn.save-btn {
            background: #10b981;
            color: white;
            border-color: #10b981;
        }
        
        .inline-action-btn.save-btn:hover {
            background: #059669;
            border-color: #059669;
        }
        
        .inline-action-btn.cancel-btn {
            background: #6b7280;
            color: white;
            border-color: #6b7280;
        }
        
        .inline-action-btn.cancel-btn:hover {
            background: #4b5563;
            border-color: #4b5563;
        }
        
        .inline-form-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }
        
        .inline-form-group {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }
        
        .inline-form-group.full-width {
            grid-column: 1 / -1;
        }
        
        .inline-form-group label {
            font-size: 0.875rem;
            font-weight: 500;
            color: #374151;
        }
        
        .inline-form-input, .inline-form-select, .inline-form-textarea {
            padding: 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 0.875rem;
            transition: border-color 0.2s;
        }
        
        .inline-form-input:focus, .inline-form-select:focus, .inline-form-textarea:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        .inline-form-textarea {
            resize: vertical;
            min-height: 80px;
        }
        
        @media (max-width: 768px) {
            .inline-form-grid {
                grid-template-columns: 1fr;
            }
            
            .inline-form-actions {
                flex-direction: column;
            }
            
            .inline-action-btn {
                justify-content: center;
            }
        }
        
        .confirmation-dialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1001;
        }
        
        .confirmation-content {
            background: white;
            border-radius: 8px;
            padding: 1.5rem;
            max-width: 400px;
            width: 90%;
        }
        
        .confirmation-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 1rem;
        }
        
        .confirmation-message {
            color: #6b7280;
            margin-bottom: 1.5rem;
        }
        
        .confirmation-actions {
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end;
        }
        
        .confirm-btn {
            background: #dc2626;
            color: white;
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            font-size: 0.875rem;
            cursor: pointer;
        }
        
        .confirm-btn:hover {
            background: #b91c1c;
        }
        
        .cancel-confirm-btn {
            background: #f3f4f6;
            color: #374151;
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            font-size: 0.875rem;
            cursor: pointer;
        }
        
        .cancel-confirm-btn:hover {
            background: #e5e7eb;
        }
        
        /* #SUGGEST_RESPONSIVE: Mobile responsiveness for modal interface
           Complex tabbed interface may need different layout on mobile */
        @media (max-width: 768px) {
            .task-modal-content {
                width: 95vw;
                height: 90vh;
                margin: 1rem;
            }
            
            .knowledge-modal-content {
                width: 95vw;
                margin: 1rem;
            }
            
            .modal-header {
                flex-direction: column;
                gap: 1rem;
                align-items: stretch;
                padding: 1rem;
            }
            
            .modal-header-actions {
                justify-content: space-between;
                flex-wrap: wrap;
                gap: 0.5rem;
            }
            
            .knowledge-search-container {
                flex-direction: column;
                gap: 0.75rem;
            }
            
            .search-input-wrapper {
                max-width: none;
            }
            
            .category-filter {
                min-width: auto;
                width: 100%;
            }
            
            .form-grid {
                grid-template-columns: 1fr;
            }
            
            .action-btn {
                padding: 0.5rem 0.75rem;
                font-size: 0.8rem;
            }
            
            .overview-sections {
                grid-template-columns: 1fr;
            }
            
            .modal-tabs {
                overflow-x: scroll;
                scrollbar-width: none;
                -ms-overflow-style: none;
            }
            
            .modal-tabs::-webkit-scrollbar {
                display: none;
            }
            
            .ra-tags-header {
                flex-direction: column;
            }
            
            .log-header {
                flex-direction: column;
                align-items: stretch;
            }
            
            .header {
                flex-direction: column;
                gap: 1rem;
                padding: 1rem 0.75rem;
            }
            
            .header-filters {
                gap: 1rem;
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .filter-select {
                min-width: 120px;
            }
        }
        
        /* Additional styles for assumption insights functionality */
        .table-row.clickable {
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        
        .table-row.clickable:hover {
            background-color: #f8fafc;
        }
        
        .success-rate-value.high-risk {
            color: #dc2626;
            font-weight: 600;
        }
        
        .success-rate-value.medium-risk {
            color: #ea580c;
            font-weight: 600;
        }
        
        .success-rate-value.low-risk {
            color: #16a34a;
            font-weight: 600;
        }
        
        .success-rate-bar {
            width: 100%;
            height: 4px;
            background-color: #e5e7eb;
            border-radius: 2px;
            margin-top: 4px;
            overflow: hidden;
        }
        
        .success-rate-fill {
            height: 100%;
            transition: width 0.3s ease;
        }
        
        .success-rate-fill.high-risk {
            background-color: #dc2626;
        }
        
        .success-rate-fill.medium-risk {
            background-color: #ea580c;
        }
        
        .success-rate-fill.low-risk {
            background-color: #16a34a;
        }
        
        .outcome-badge.success {
            background-color: #dcfce7;
            color: #166534;
        }
        
        .outcome-badge.warning {
            background-color: #fef3c7;
            color: #92400e;
        }
        
        .outcome-badge.danger {
            background-color: #fee2e2;
            color: #991b1b;
        }
        
        .validation-counts {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            font-size: 0.875rem;
            color: #6b7280;
        }
        
        .tag-pill {
            background-color: #eff6ff;
            color: #1e40af;
            padding: 0.125rem 0.5rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 500;
            border: 1px solid #dbeafe;
        }
        
        .task-link {
            color: #3b82f6;
            text-decoration: none;
            font-weight: 500;
        }
        
        .task-link:hover {
            text-decoration: underline;
        }
        
        .reason-cell {
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .drawer-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            color: #6b7280;
            font-size: 0.875rem;
        }
        
        .drawer-loading .spinner {
            margin-right: 0.5rem;
        }
        
        .metric-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 0;
            border-bottom: 1px solid #e5e7eb;
        }
        
        .metric-item:last-child {
            border-bottom: none;
        }
        
        .metric-label {
            font-weight: 500;
            color: #374151;
        }
        
        .metric-value {
            font-weight: 600;
            font-size: 1.125rem;
        }
        
        .metric-value.success {
            color: #16a34a;
        }
        
        .metric-value.warning {
            color: #ea580c;
        }
        
        .metric-value.danger {
            color: #dc2626;
        }
        
        .history-item {
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 1rem;
            margin-bottom: 0.75rem;
            background-color: #ffffff;
        }
        
        .history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        
        .history-timestamp {
            font-size: 0.75rem;
            color: #6b7280;
        }
        
        .history-content {
            font-size: 0.875rem;
        }
        
        .history-reason {
            margin: 0.5rem 0;
            color: #374151;
        }
        
        .history-task {
            margin: 0;
            font-size: 0.8125rem;
            color: #6b7280;
            font-style: italic;
        }
        
        .reason-item {
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 1rem;
            margin-bottom: 0.75rem;
            background-color: #ffffff;
        }
        
        .reason-text {
            font-weight: 500;
            color: #374151;
            margin-bottom: 0.5rem;
        }
        
        .reason-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.8125rem;
            color: #6b7280;
        }
        
        .reason-count {
            font-weight: 500;
        }
        
        .reason-outcome {
            font-weight: 500;
        }
        
        .reason-outcome.success {
            color: #16a34a;
        }
        
        .reason-outcome.warning {
            color: #ea580c;
        }
        
        .reason-outcome.danger {
            color: #dc2626;
        }
        
        .no-data {
            text-align: center;
            color: #6b7280;
            font-style: italic;
            padding: 2rem;
        }
        
        .error-state {
            text-align: center;
            padding: 2rem;
        }
        
        .error-message {
            color: #dc2626;
            font-weight: 500;
        }

    </style>
</head>
<body>
    <header class="header">
        <div class="header-left">
            <svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg" width="28" height="28" role="img" aria-label="Commands.com">
                <g transform="matrix(1,0,0,1,0.5,0.5)">
                    <path d="M31,5C31,2.792 29.208,1 27,1L5,1C2.792,1 1,2.792 1,5L1,27C1,29.208 2.792,31 5,31L27,31C29.208,31 31,29.208 31,27L31,5Z" style="fill:rgb(18,25,41);"/>
                    <path d="M31,5C31,2.792 29.208,1 27,1L5,1C2.792,1 1,2.792 1,5L1,27C1,29.208 2.792,31 5,31L27,31C29.208,31 31,29.208 31,27L31,5Z" style="fill:none;stroke:rgb(81,162,255);stroke-width:1.8px;"/>
                    <path d="M9,10L16,16L9,22" style="fill:none;fill-rule:nonzero;stroke:rgb(81,162,255);stroke-width:2.6px;"/>
                    <rect x="21" y="8" width="2" height="16" style="fill:rgb(81,162,255);"/>
                </g>
            </svg>
            <h1>Commands.com RA PM Dashboard</h1>
            <button id="knowledgeBtn" class="knowledge-btn" title="Knowledge Management">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path>
                    <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>
                </svg>
            </button>
            <button id="assumptionInsightsBtn" class="knowledge-btn" title="Assumption Insights Dashboard">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="20" x2="18" y2="10"></line>
                    <line x1="12" y1="20" x2="12" y2="4"></line>
                    <line x1="6" y1="20" x2="6" y2="14"></line>
                </svg>
            </button>
        </div>
        <div class="header-filters">
            <div class="filter-group">
                <label for="projectSelector" class="filter-label">Project:</label>
                <select id="projectSelector" class="filter-select">
                    <option value="">All Projects</option>
                </select>
            </div>
            <div class="filter-group">
                <label for="epicSelector" class="filter-label">Epic:</label>
                <select id="epicSelector" class="filter-select">
                    <option value="">All Epics</option>
                </select>
                <button id="deleteFilterButton" class="delete-filter-btn" title="Delete selected project or epic" style="display: none;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M3 6h18"></path>
                        <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path>
                        <path d="M8 6V4c0-1 1-2 2-2h4c0 1 1 2 2 2v2"></path>
                    </svg>
                </button>
            </div>
        </div>
        <span id="connectionStatus" class="connection-status connecting">Connecting...</span>
    </header>
    
    <main class="board">
        <div class="column" data-status="TODO">
            <div class="column-header">
                <div class="column-title-container">
                    <div class="column-title" id="todo-column-title">TODO</div>
                    <button id="todo-backlog-toggle" class="toggle-btn" title="Toggle between TODO and Backlog view">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M3 12h18m0 0l-6-6m6 6l-6 6"/>
                        </svg>
                    </button>
                </div>
                <div class="task-count" id="todo-count">0 tasks</div>
            </div>
            <div class="tasks" id="todo-tasks">
                <div class="loading">
                    <span class="spinner"></span>
                    Loading tasks...
                </div>
            </div>
        </div>
        
        <div class="column" data-status="IN_PROGRESS">
            <div class="column-header">
                <div class="column-title">IN PROGRESS</div>
                <div class="task-count" id="in_progress-count">0 tasks</div>
            </div>
            <div class="tasks" id="in_progress-tasks">
                <div class="loading">
                    <span class="spinner"></span>
                    Loading tasks...
                </div>
            </div>
        </div>
        
        <div class="column" data-status="REVIEW">
            <div class="column-header">
                <div class="column-title">REVIEW</div>
                <div class="task-count" id="review-count">0 tasks</div>
            </div>
            <div class="tasks" id="review-tasks">
                <div class="loading">
                    <span class="spinner"></span>
                    Loading tasks...
                </div>
            </div>
        </div>
        
        <div class="column" data-status="DONE">
            <div class="column-header">
                <div class="column-title">DONE</div>
                <div class="task-count" id="done-count">0 tasks</div>
            </div>
            <div class="tasks" id="done-tasks">
                <div class="loading">
                    <span class="spinner"></span>
                    Loading tasks...
                </div>
            </div>
        </div>
    </main>
    
    <!-- #COMPLETION_DRIVE_MODAL: Task Detail Modal with comprehensive RA data display
         Assumption: Modal follows standard UX patterns with backdrop close and tab navigation -->
    <div id="taskDetailModal" class="task-modal" style="display: none;">
        <div class="task-modal-content">
            <div class="modal-header">
                <h2 id="modalTaskTitle" class="modal-title">Task Details</h2>
                <button id="modalCloseBtn" class="modal-close-btn" aria-label="Close Modal">&times;</button>
            </div>
            
            <div class="modal-tabs">
                <button class="modal-tab active" data-tab="overview">Overview</button>
                <button class="modal-tab" data-tab="ra-tags">RA Tags</button>
                <button class="modal-tab" data-tab="execution-log">Execution Log</button>
                <button class="modal-tab" data-tab="system-prompt">System Prompt</button>
                <button class="modal-tab" data-tab="dependencies">Dependencies</button>
            </div>
            
            <div class="modal-content-area">
                <!-- Overview Tab -->
                <div id="overview-tab" class="tab-content active">
                    <div class="overview-sections">
                        <div class="overview-main">
                            <div id="taskDescription" class="task-description"></div>
                            <div id="taskMetrics" class="task-metrics"></div>
                        </div>
                        <div class="overview-sidebar">
                            <div id="taskBreadcrumb" class="task-breadcrumb-full"></div>
                            <div id="taskTimestamps" class="task-timestamps"></div>
                            <div id="taskStatus" class="task-status-info"></div>
                        </div>
                    </div>
                </div>
                
                <!-- RA Tags Tab -->
                <div id="ra-tags-tab" class="tab-content">
                    <div class="ra-tags-header">
                        <input type="text" id="tagsSearchInput" placeholder="Search tags..." class="tags-search-input">
                        <div id="tagsCategoryFilter" class="tags-category-filter"></div>
                    </div>
                    <div id="raTagsContainer" class="ra-tags-container"></div>
                </div>
                
                <!-- Execution Log Tab -->
                <div id="execution-log-tab" class="tab-content">
                    <div class="log-header">
                        <div class="log-filters">
                            <select id="logTypeFilter" class="log-filter-select">
                                <option value="all">All Types</option>
                                <option value="prompt">Prompts</option>
                                <option value="ra_tag">RA Tags</option>
                                <option value="status">Status Updates</option>
                                <option value="update">Updates</option>
                            </select>
                            <button id="logRefreshBtn" class="log-refresh-btn">Refresh</button>
                        </div>
                        <div id="logPagination" class="log-pagination"></div>
                    </div>
                    <div id="executionLogContainer" class="execution-log-container"></div>
                </div>
                
                <!-- System Prompt Tab -->
                <div id="system-prompt-tab" class="tab-content">
                    <div class="prompt-header">
                        <div id="promptVersion" class="prompt-version"></div>
                        <button id="promptCopyBtn" class="prompt-copy-btn">Copy to Clipboard</button>
                    </div>
                    <div id="systemPromptContainer" class="system-prompt-container">
                        <pre id="systemPromptContent" class="system-prompt-content"></pre>
                    </div>
                </div>
                
                <!-- Dependencies Tab -->
                <div id="dependencies-tab" class="tab-content">
                    <div class="dependencies-stats">
                        <div id="dependencyStats" class="dependency-stats"></div>
                    </div>
                    <div id="dependenciesContainer" class="dependencies-container"></div>
                </div>
            </div>
            
            <div class="modal-loading" id="modalLoading" style="display: none;">
                <div class="spinner"></div>
                <span>Loading task details...</span>
            </div>
        </div>
    </div>
    
    <script>
        // #COMPLETION_DRIVE_ARCHITECTURE: Global state management for WebSocket and UI
        // Assumption: Single global state object simplifies state management in single-page context
        const AppState = {
            socket: null,
            reconnectDelay: 1000,
            maxReconnectDelay: 30000,
            connectionAttempts: 0,
            maxConnectionAttempts: 10,
            tasks: new Map(),
            projects: new Map(),
            epics: new Map(),
            selectedProjectId: null,
            selectedEpicId: null,
            pendingUpdates: new Map(),
            isOnline: navigator.onLine,
            pollingInterval: null,
            pollingDelay: 5000,
            todoViewMode: 'TODO' // 'TODO' or 'BACKLOG'
        };
        
        // #COMPLETION_DRIVE_WEBSOCKET: WebSocket connection with exponential backoff
        // Pattern: Auto-reconnection with increasing delays prevents server overload
        function initializeWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws/updates`;
            
            console.log(`Attempting WebSocket connection to: ${wsUrl}`);
            
            try {
                AppState.socket = new WebSocket(wsUrl);
                
                AppState.socket.onopen = function(event) {
                    console.log('WebSocket connected successfully');
                    AppState.reconnectDelay = 1000; // Reset backoff
                    AppState.connectionAttempts = 0;
                    updateConnectionStatus('connected');
                    
                    // Stop polling fallback if active
                    if (AppState.pollingInterval) {
                        clearInterval(AppState.pollingInterval);
                        AppState.pollingInterval = null;
                    }
                };
                
                AppState.socket.onmessage = function(event) {
                    try {
                        const data = JSON.parse(event.data);
                        console.log('WebSocket message received:', data);
                        handleRealtimeUpdate(data);
                    } catch (error) {
                        console.error('Failed to parse WebSocket message:', error);
                    }
                };
                
                AppState.socket.onclose = function(event) {
                    console.log('WebSocket connection closed:', event.code, event.reason);
                    AppState.socket = null;
                    updateConnectionStatus('disconnected');
                    
                    // #COMPLETION_DRIVE_FALLBACK: Implement polling fallback for poor connections
                    // Assumption: Fallback ensures functionality when WebSocket is unreliable
                    startPollingFallback();
                    
                    // Attempt reconnection with exponential backoff
                    if (AppState.connectionAttempts < AppState.maxConnectionAttempts) {
                        AppState.connectionAttempts++;
                        setTimeout(() => {
                            if (!AppState.socket || AppState.socket.readyState === WebSocket.CLOSED) {
                                initializeWebSocket();
                            }
                        }, AppState.reconnectDelay);
                        
                        AppState.reconnectDelay = Math.min(
                            AppState.reconnectDelay * 2, 
                            AppState.maxReconnectDelay
                        );
                    }
                };
                
                AppState.socket.onerror = function(error) {
                    console.error('WebSocket error:', error);
                    updateConnectionStatus('disconnected');
                };
                
            } catch (error) {
                console.error('Failed to create WebSocket connection:', error);
                updateConnectionStatus('disconnected');
                startPollingFallback();
            }
        }
        
        // #COMPLETION_DRIVE_RESILIENCE: Polling fallback for network issues
        // Pattern: Ensures dashboard remains functional when WebSocket fails
        function startPollingFallback() {
            if (AppState.pollingInterval) return; // Already polling
            
            console.log('Starting polling fallback');
            AppState.pollingInterval = setInterval(async () => {
                try {
                    await loadBoardState();
                } catch (error) {
                    console.error('Polling fallback failed:', error);
                }
            }, AppState.pollingDelay);
        }
        
        function updateConnectionStatus(status) {
            const statusElement = document.getElementById('connectionStatus');
            statusElement.className = `connection-status ${status}`;
            
            switch (status) {
                case 'connected':
                    statusElement.textContent = 'Connected';
                    break;
                case 'connecting':
                    statusElement.textContent = 'Connecting...';
                    break;
                case 'disconnected':
                    statusElement.textContent = 'Disconnected';
                    break;
            }
        }
        
        // #COMPLETION_DRIVE_REALTIME: Handle real-time updates from WebSocket with enriched payloads
        // Pattern: Event-driven updates maintain UI consistency across clients with enhanced payload support
        function handleRealtimeUpdate(data) {
            console.log('Processing real-time update:', data);
            
            switch (data.type) {
                case 'task.status_changed':
                    handleTaskStatusUpdate(data);
                    break;
                case 'task.locked':
                    handleTaskLocked(data);
                    break;
                case 'task.unlocked':
                    handleTaskUnlocked(data);
                    break;
                case 'task.created':
                    handleTaskCreated(data);
                    break;
                case 'task.updated':
                    handleTaskUpdated(data);
                    break;
                case 'task.logs.appended':
                    handleTaskLogsAppended(data);
                    break;
                case 'project_deleted':
                    handleProjectDeleted(data);
                    break;
                case 'epic_deleted':
                    handleEpicDeleted(data);
                    break;
                case 'knowledge_upserted':
                    handleKnowledgeUpserted(data);
                    break;
                case 'knowledge_query':
                    handleKnowledgeQuery(data);
                    break;
                case 'knowledge_deleted':
                    handleKnowledgeDeleted(data);
                    break;
                case 'knowledge_log':
                    handleKnowledgeLog(data);
                    break;
                default:
                    console.log('Unknown event type:', data.type);
            }
        }
        
        function handleTaskStatusUpdate(data) {
            const task = AppState.tasks.get(String(data.task_id));
            if (task) {
                // #COMPLETION_DRIVE_CONFLICT: Skip update if user has pending operation
                // Assumption: User's optimistic update takes precedence over remote updates
                if (AppState.pendingUpdates.has(String(data.task_id))) {
                    console.log('Skipping remote update due to pending local update');
                    return;
                }
                
                task.status = data.status;
                task.agent_id = data.agent_id;
                AppState.tasks.set(String(data.task_id), task);
                renderTask(task);
                updateTaskCounts();
            } else {
                // If task not found locally (stale state), resync board
                console.log('Task not found in state for status update; reloading board state');
                loadBoardState();
            }
        }
        
        function handleTaskLocked(data) {
            const task = AppState.tasks.get(String(data.task_id));
            if (task) {
                task.lock_holder = data.agent_id;
                AppState.tasks.set(String(data.task_id), task);
                renderTask(task);
            } else {
                console.log('Task not found in state for lock; reloading board state');
                loadBoardState();
            }
        }
        
        function handleTaskUnlocked(data) {
            const task = AppState.tasks.get(String(data.task_id));
            if (task) {
                task.lock_holder = null;
                AppState.tasks.set(String(data.task_id), task);
                renderTask(task);
            } else {
                console.log('Task not found in state for unlock; reloading board state');
                loadBoardState();
            }
        }
        
        // #COMPLETION_DRIVE_IMPL: Enhanced event handlers for enriched WebSocket payloads
        // New event types support auto-switch functionality and comprehensive real-time updates
        
        function handleTaskCreated(data) {
            console.log('Task created event received:', data);
            
            // #COMPLETION_DRIVE_INTEGRATION: Extract enriched task data from event payload
            const enrichedData = data.data || data;
            const taskData = enrichedData.task;
            const projectData = enrichedData.project;
            const epicData = enrichedData.epic;
            const flags = enrichedData.flags || {};
            const initiator = enrichedData.initiator;
            
            if (taskData) {
                // Create task object compatible with existing UI structure
                const task = {
                    id: taskData.id,
                    name: taskData.name,
                    description: taskData.description,
                    status: taskData.status || 'TODO',
                    epic_id: taskData.epic_id,
                    project_id: projectData ? projectData.id : null,
                    ra_score: taskData.ra_score,
                    ra_mode: taskData.ra_mode,
                    complexity_score: taskData.ra_score || taskData.complexity_score, // Alias for UI compatibility
                    mode_used: taskData.ra_mode || taskData.mode_used, // Alias for UI compatibility
                    estimated_hours: taskData.ra_metadata?.estimated_hours || 'N/A', // Extract from ra_metadata
                    created_at: taskData.created_at,
                    updated_at: taskData.updated_at,
                    project_name: projectData ? projectData.name : null,
                    epic_name: epicData ? epicData.name : null
                };
                
                // Add task to state
                AppState.tasks.set(String(task.id), task);
                
                // Update projects and epics data if provided
                if (projectData) {
                    AppState.projects.set(String(projectData.id), projectData);
                }
                if (epicData) {
                    AppState.epics.set(String(epicData.id), epicData);
                }
                
                // Re-populate selectors if new project/epic was created
                if (flags.project_created) {
                    populateProjectSelector();
                }
                if (flags.epic_created) {
                    populateEpicSelector();
                }
                
                // Only render and update counts if task matches current filter
                const filteredTasks = getFilteredTasks();
                if (filteredTasks.some(t => t.id === task.id)) {
                    renderTask(task);
                    updateTaskCounts();
                } else {
                    // Task exists but doesn't match filter - still update counts
                    updateTaskCounts();
                }
                
                // #COMPLETION_DRIVE_INTEGRATION: Auto-switch logic for dashboard clients
                // Check if this event should trigger auto-switch behavior
                if (enrichedData.auto_switch_recommended && initiator) {
                    // #SUGGEST_EDGE_CASE: Implement session-based auto-switch logic
                    // For now, show notification about new task creation
                    let switchMessage = `New task created: ${task.name}`;
                    
                    if (flags.project_created) {
                        switchMessage += ` (new project: ${projectData?.name})`;
                    }
                    if (flags.epic_created) {
                        switchMessage += ` (new epic: ${epicData?.name})`;
                    }
                    
                    showNotification(switchMessage, 'success', 5000);
                }
            }
        }
        
        function handleTaskUpdated(data) {
            console.log('Task updated event received:', data);
            
            // #COMPLETION_DRIVE_INTEGRATION: Extract enriched update data from event payload
            const enrichedData = data.data || data;
            const taskData = enrichedData.task;
            const changedFields = enrichedData.changed_fields || [];
            const fieldChanges = enrichedData.field_changes || {};
            
            if (taskData && taskData.id) {
                const taskId = String(taskData.id);
                
                // Skip update if user has pending operation to avoid conflicts
                if (AppState.pendingUpdates.has(taskId)) {
                    console.log('Skipping remote task update due to pending local update');
                    return;
                }
                
                // Get existing task or create new one
                let task = AppState.tasks.get(taskId) || {};
                
                // Update task with enriched data
                Object.assign(task, {
                    id: taskData.id,
                    name: taskData.name,
                    description: taskData.description,
                    status: taskData.status,
                    epic_id: taskData.epic_id,
                    ra_score: taskData.ra_score,
                    ra_mode: taskData.ra_mode,
                    complexity_score: taskData.ra_score || taskData.complexity_score, // UI compatibility
                    mode_used: taskData.ra_mode || taskData.mode_used, // UI compatibility
                    estimated_hours: taskData.ra_metadata?.estimated_hours || 'N/A', // Extract from ra_metadata
                    created_at: taskData.created_at,
                    updated_at: taskData.updated_at,
                    project_name: enrichedData.project ? enrichedData.project.name : task.project_name,
                    epic_name: enrichedData.epic ? enrichedData.epic.name : task.epic_name
                });
                
                // Update state
                AppState.tasks.set(taskId, task);
                
                // Check if task should be visible in current filter
                const wasVisible = document.getElementById(`task-${task.id}`) !== null;
                const shouldBeVisible = getFilteredTasks().some(t => t.id === task.id);
                
                if (shouldBeVisible) {
                    renderTask(task);
                } else if (wasVisible) {
                    // Task was visible but no longer matches filter - remove it
                    const taskElement = document.getElementById(`task-${task.id}`);
                    if (taskElement) {
                        taskElement.remove();
                    }
                }
                
                updateTaskCounts();
                
                // Show notification about significant changes
                if (changedFields.includes('status')) {
                    const statusChange = fieldChanges.status;
                    if (statusChange) {
                        showNotification(`Task "${task.name}" moved to ${statusChange.new}`, 'info');
                    }
                }
                
                // Update task detail modal if it's currently showing this task
                if (taskDetailModal && taskDetailModal.currentTask && 
                    taskDetailModal.currentTask.id == taskData.id) {
                    // #SUGGEST_EDGE_CASE: Consider refreshing modal data for real-time updates
                    console.log('Task detail modal is open for updated task - consider refreshing');
                }
            }
        }
        
        function handleTaskLogsAppended(data) {
            console.log('Task logs appended event received:', data);
            
            // #COMPLETION_DRIVE_IMPL: Handle real-time log updates for task detail modal
            const logsData = data.data || data;
            const taskId = logsData.task_id;
            const logEntries = logsData.log_entries || [];
            
            // If task detail modal is open for this task, update the logs
            if (taskDetailModal && taskDetailModal.currentTask && 
                taskDetailModal.currentTask.id == taskId &&
                taskDetailModal.activeTab === 'execution-log') {
                
                // #SUGGEST_IMPLEMENTATION: Real-time log appending in modal
                // For now, show notification about new log entries
                showNotification(`${logEntries.length} new log entr${logEntries.length === 1 ? 'y' : 'ies'} added`, 'info');
                
                // Optional: Auto-refresh logs in modal
                setTimeout(() => {
                    if (taskDetailModal.currentTask && taskDetailModal.currentTask.id == taskId) {
                        taskDetailModal.refreshExecutionLogs();
                    }
                }, 500);
            }
        }
        
        function handleProjectDeleted(data) {
            console.log('Project deleted event received:', data);
            
            const projectId = String(data.project_id);
            
            // Remove project from AppState
            if (AppState.projects.has(projectId)) {
                AppState.projects.delete(projectId);
            }
            
            // Remove all epics belonging to this project
            AppState.epics.forEach((epic, epicId) => {
                if (epic.project_id == data.project_id) {
                    AppState.epics.delete(epicId);
                }
            });
            
            // Remove all tasks belonging to this project
            AppState.tasks.forEach((task, taskId) => {
                if (task.project_id == data.project_id) {
                    AppState.tasks.delete(taskId);
                }
            });
            
            // Reset selections if deleted project was selected
            if (AppState.selectedProjectId == data.project_id) {
                AppState.selectedProjectId = null;
                AppState.selectedEpicId = null;
                saveSelectionState();
            }
            
            // Update UI
            populateProjectSelector();
            populateEpicSelector();
            updateDeleteButtonVisibility();
            renderAllTasks();
            updateTaskCounts();
            
            // Show notification
            showNotification(`Project "${data.project_name}" deleted successfully`, 'success');
        }
        
        function handleEpicDeleted(data) {
            console.log('Epic deleted event received:', data);
            
            const epicId = String(data.epic_id);
            
            // Remove epic from AppState
            if (AppState.epics.has(epicId)) {
                AppState.epics.delete(epicId);
            }
            
            // Remove all tasks belonging to this epic
            AppState.tasks.forEach((task, taskId) => {
                if (task.epic_id == data.epic_id) {
                    AppState.tasks.delete(taskId);
                }
            });
            
            // Reset epic selection if deleted epic was selected
            if (AppState.selectedEpicId == data.epic_id) {
                AppState.selectedEpicId = null;
                saveSelectionState();
            }
            
            // Update UI
            populateEpicSelector();
            updateDeleteButtonVisibility();
            renderAllTasks();
            updateTaskCounts();
            
            // Show notification
            showNotification(`Epic "${data.epic_name}" deleted successfully`, 'success');
        }
        
        function handleKnowledgeUpserted(data) {
            console.log('Knowledge upserted event received:', data);
            
            // If the knowledge modal is open, refresh its data
            if (knowledgeModal && knowledgeModal.isOpen) {
                knowledgeModal.loadKnowledgeData();
            }
            
            // Show notification for knowledge updates
            const operation = data.operation || 'updated';
            const knowledgeItem = data.knowledge_item || {};
            const title = knowledgeItem.title || 'Knowledge item';
            
            showNotification(`${title} ${operation} successfully`, 'success');
        }
        
        function handleKnowledgeQuery(data) {
            console.log('Knowledge query event received:', data);
            
            // This appears to be a query result event, could be used for search results
            // or knowledge retrieval operations. Currently just logging for visibility.
            const resultCount = data.result_count || 0;
            console.log(`Knowledge query returned ${resultCount} results`);
        }
        
        function handleKnowledgeDeleted(data) {
            console.log('Knowledge deleted event received:', data);
            
            // If the knowledge modal is open, refresh its data to remove deleted item
            if (knowledgeModal && knowledgeModal.isOpen) {
                knowledgeModal.loadKnowledgeData();
            }
            
            // Show notification for knowledge deletion
            showNotification(`Knowledge item deleted successfully`, 'success');
        }
        
        function handleKnowledgeLog(data) {
            console.log('Knowledge log event received:', data);
            
            // If the knowledge modal is open and showing the item that was logged,
            // refresh the log display in real-time
            const knowledgeId = data.knowledge_id;
            const action = data.action_type || 'activity';
            
            if (knowledgeModal && knowledgeModal.isOpen) {
                console.log(`Knowledge item ${knowledgeId} had ${action} activity - refreshing logs`);
                
                // Refresh the logs for this specific knowledge item if they're currently expanded
                knowledgeModal.refreshKnowledgeLogs(knowledgeId);
                
                // Show a subtle notification about the new activity
                showNotification(`New ${action} logged for knowledge item`, 'info', 2000);
            }
        }
        
        // #COMPLETION_DRIVE_INIT: Load initial board state from API
        // Pattern: Fetch complete state on page load, then maintain via WebSocket
        async function loadBoardState() {
            try {
                console.log('Loading board state...');
                const response = await fetch('/api/board/state');
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('Board state loaded:', data);
                
                // Clear existing data
                AppState.tasks.clear();
                AppState.projects.clear();
                AppState.epics.clear();
                
                // Process projects from API response
                if (data.projects && Array.isArray(data.projects)) {
                    data.projects.forEach(project => {
                        AppState.projects.set(String(project.id), project);
                    });
                }
                
                // Process epics from API response
                if (data.epics && Array.isArray(data.epics)) {
                    data.epics.forEach(epic => {
                        AppState.epics.set(String(epic.id), epic);
                    });
                }
                
                // Process tasks from API response
                if (data.tasks && Array.isArray(data.tasks)) {
                    data.tasks.forEach(task => {
                        console.log(`Loading task: ID=${task.id}, Name=${task.name}`);
                        AppState.tasks.set(String(task.id), task);
                    });
                    console.log(`Total tasks loaded: ${AppState.tasks.size}`);
                    console.log('Task IDs:', Array.from(AppState.tasks.keys()));
                }
                
                // Load saved selections from localStorage
                loadSelectionState();
                
                // Update UI
                populateProjectSelector();
                populateEpicSelector();
                renderAllTasks();
                updateTaskCounts();
                
            } catch (error) {
                console.error('Failed to load board state:', error);
                showNotification('Failed to load tasks', 'error');
                
                // Show error state in UI
                document.querySelectorAll('.loading').forEach(loader => {
                    loader.innerHTML = '<span style="color: #f56565;">Failed to load</span>';
                });
            }
        }
        
        function renderAllTasks() {
            // Clear all task containers
            ['todo', 'in_progress', 'review', 'done'].forEach(status => {
                const container = document.getElementById(`${status.replace('_', '_')}-tasks`);
                container.innerHTML = '';
            });
            
            // Render filtered tasks
            const filteredTasks = getFilteredTasks();
            filteredTasks.forEach(task => renderTask(task));
        }
        
        // Status mapping between database vocabulary and UI vocabulary
        function mapDatabaseStatusToUI(dbStatus) {
            const statusMap = {
                'pending': 'todo',
                'in_progress': 'in_progress',
                'review': 'review', 
                'completed': 'done',
                'blocked': 'todo', // Blocked tasks appear in TODO for now
                'backlog': 'backlog', // Backlog tasks have their own status
                'todo': 'todo', // Handle UI status format
                'done': 'done',  // Handle UI status format
                'backlog': 'backlog' // Handle UI status format
            };
            const normalizedStatus = (dbStatus || 'pending').toLowerCase().trim();
            return statusMap[normalizedStatus] || 'todo'; // Default to todo for unknown statuses
        }

        // #COMPLETION_DRIVE_RA: Enhanced task rendering with RA indicators and project context
        // Assumption: Task object contains RA-related fields (complexity_score, mode_used, ra_tags, etc.)
        function renderTask(task) {
            let statusKey = mapDatabaseStatusToUI(task.status.toLowerCase());
            
            // Handle toggle view logic: backlog tasks show in TODO column when in backlog view
            if (statusKey === 'backlog' && AppState.todoViewMode === 'BACKLOG') {
                statusKey = 'todo'; // Show backlog tasks in TODO column
            } else if (statusKey === 'todo' && AppState.todoViewMode === 'BACKLOG') {
                return; // Hide TODO tasks when in backlog view
            } else if (statusKey === 'backlog' && AppState.todoViewMode === 'TODO') {
                return; // Hide backlog tasks when in TODO view
            }
            
            const container = document.getElementById(`${statusKey}-tasks`);
            
            if (!container) {
                console.error(`No container found for status: ${task.status}`);
                return;
            }
            
            // Remove existing task element if it exists
            const existingElement = document.getElementById(`task-${task.id}`);
            if (existingElement) {
                existingElement.remove();
            }
            
            // Create task card element
            const taskElement = document.createElement('div');
            taskElement.className = `task-card ${task.lock_holder ? 'locked' : ''}`;
            taskElement.id = `task-${task.id}`;
            taskElement.draggable = !task.lock_holder; // Only draggable if not locked
            taskElement.dataset.taskId = task.id;
            
            // Add click handler for task details modal and action buttons
            taskElement.addEventListener('click', function(e) {
                // Prevent click during drag operations
                if (e.target.closest('.task-card').classList.contains('dragging')) {
                    return;
                }
                
                // Handle action button clicks
                if (e.target.closest('.move-task-btn')) {
                    e.stopPropagation();
                    handleMoveTask(task);
                    return;
                }
                
                if (e.target.closest('.delete-task-btn')) {
                    e.stopPropagation();
                    handleDeleteTask(task);
                    return;
                }
                
                // Open task details modal for regular clicks
                openTaskDetailModal(task);
            });
            
            // Build RA indicators
            const raIndicators = buildRAIndicators(task);
            const projectBreadcrumb = buildProjectBreadcrumb(task);
            const taskMeta = buildTaskMeta(task);
            
            taskElement.innerHTML = `
                ${projectBreadcrumb}
                <div class="task-title">${escapeHtml(task.name || 'Untitled Task')}</div>
                ${raIndicators}
                ${taskMeta}
                <div class="task-actions">
                    <button class="task-action-btn move-task-btn" title="${task.status === 'backlog' || task.status === 'BACKLOG' ? 'Move to TODO' : 'Move to Backlog'}" data-task-id="${task.id}" data-current-status="${task.status}">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M3 12h18m0 0l-6-6m6 6l-6 6"/>
                        </svg>
                    </button>
                    <button class="task-action-btn delete-task-btn" title="Delete task" data-task-id="${task.id}">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M3 6h18"></path>
                            <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path>
                            <path d="M8 6V4c0-1 1-2 2-2h4c0 1 1 2 2 2v2"></path>
                        </svg>
                    </button>
                </div>
            `;
            
            container.appendChild(taskElement);
        }
        
        // #COMPLETION_DRIVE_RA: Build RA indicator elements with graceful degradation
        // Assumption: Missing RA data should not break the UI - show what's available
        function buildRAIndicators(task) {
            let indicators = [];
            
            // Complexity score badge
            if (task.ra_score) {
                const score = parseInt(task.ra_score);
                let scoreClass = 'score-1-3'; // Default to simple
                if (score >= 9) scoreClass = 'score-9-10';
                else if (score >= 7) scoreClass = 'score-7-8';
                else if (score >= 4) scoreClass = 'score-4-6';
                
                indicators.push(`<span class="complexity-badge ${scoreClass}">${score}</span>`);
            }
            
            // Mode badge
            if (task.ra_mode) {
                const mode = task.ra_mode.toLowerCase().replace('-', '-');
                indicators.push(`<span class="mode-badge ${mode}">${task.ra_mode}</span>`);
            }
            
            // Dependencies count
            if (task.dependencies_count && task.dependencies_count > 0) {
                indicators.push(`<span class="dependencies-count"> ${task.dependencies_count} deps</span>`);
            }
            
            // Verification status
            if (task.verification_status) {
                const status = task.verification_status.toLowerCase();
                indicators.push(`<span class="verification-status ${status}">${task.verification_status}</span>`);
            }
            
            // RA tags summary
            if (task.ra_tags && task.ra_tags.length > 0) {
                const tagSummary = buildRATagsSummary(task.ra_tags);
                indicators.push(`<div class="ra-tags-summary">${tagSummary}</div>`);
            }
            
            // Adaptive scoring (predicted vs actual)
            if (task.predicted_complexity && task.complexity_score && 
                task.predicted_complexity !== task.complexity_score) {
                const adaptiveScore = `
                    <div class="adaptive-scoring">
                        <span class="score-comparison">
                            Predicted: ${task.predicted_complexity} 
                            <span class="score-arrow"></span> 
                            Actual: ${task.complexity_score}
                        </span>
                    </div>
                `;
                indicators.push(adaptiveScore);
            }
            
            return indicators.length > 0 ? `<div class="task-indicators">${indicators.join('')}</div>` : '';
        }
        
        // #COMPLETION_DRIVE_RA: Build RA tags summary with category breakdown
        // Assumption: RA tags are objects with 'category' and 'count' or simple array of tag objects
        function buildRATagsSummary(raTags) {
            if (!raTags || raTags.length === 0) return '';
            
            // Count tags by category (simplified approach for now)
            let totalTags = Array.isArray(raTags) ? raTags.length : 0;
            let implTags = 0;
            let suggestTags = 0;
            
            // If tags have category information, count them
            if (Array.isArray(raTags)) {
                raTags.forEach(tag => {
                    if (typeof tag === 'object' && tag.category) {
                        if (tag.category.includes('IMPL') || tag.category.includes('COMPLETION_DRIVE')) {
                            implTags++;
                        } else if (tag.category.includes('SUGGEST')) {
                            suggestTags++;
                        }
                    }
                });
            }
            
            let summary = `<span class="ra-tag-count">${totalTags} tags</span>`;
            
            if (implTags > 0 || suggestTags > 0) {
                const breakdown = [];
                if (implTags > 0) breakdown.push(`${implTags} impl`);
                if (suggestTags > 0) breakdown.push(`${suggestTags} suggest`);
                summary += ` <span style="font-size: 0.65rem;">(${breakdown.join(', ')})</span>`;
            }
            
            return summary;
        }
        
        // #COMPLETION_DRIVE_UX: Build project breadcrumb navigation context
        // Assumption: Task object may contain project_name and epic_name fields
        function buildProjectBreadcrumb(task) {
            // Show breadcrumbs in these cases:
            // 1. No project selected (All Projects) - show Project  Epic
            // 2. Project selected but no epic (All Epics in Project) - show Epic only
            const noProjectSelected = !AppState.selectedProjectId;
            const projectSelectedNoEpic = AppState.selectedProjectId && !AppState.selectedEpicId;
            const showBreadcrumb = noProjectSelected || projectSelectedNoEpic;
            
            if (!showBreadcrumb) return '';
            
            const parts = [];
            
            // Look up project and epic names from IDs if not directly available
            let projectName = task.project_name;
            let epicName = task.epic_name;
            
            // If we have epic_id but no epic_name, look it up
            if (task.epic_id && !epicName) {
                const epic = AppState.epics.get(String(task.epic_id));
                if (epic) {
                    epicName = epic.name;
                    // Also get project name from epic if not available on task
                    if (epic.project_id && !projectName) {
                        const project = AppState.projects.get(String(epic.project_id));
                        if (project) {
                            projectName = project.name;
                        }
                    }
                }
            }
            
            // Determine what to show based on current filter state
            if (noProjectSelected) {
                // All Projects view - show Project  Epic
                if (projectName) parts.push(escapeHtml(projectName));
                if (epicName) parts.push(escapeHtml(epicName));
            } else if (projectSelectedNoEpic) {
                // Project selected, All Epics in Project view - show Epic only
                if (epicName) parts.push(escapeHtml(epicName));
            }
            
            if (parts.length === 0) return '';
            
            return `
                <div class="project-breadcrumb">
                    ${parts.join('<span class="breadcrumb-separator"></span>')}
                </div>
            `;
        }
        
        // #COMPLETION_DRIVE_UX: Build task metadata section with existing agent/lock info
        // Pattern: Maintain existing functionality while adding RA context
        function buildTaskMeta(task) {
            const lockInfo = task.lock_holder ? 
                `<span class="task-locked-info"> ${task.lock_holder}</span>` : '';
            
            const agentInfo = task.agent_id ? 
                `<span class="task-agent">${task.agent_id}</span>` : '';
            
            return `
                <div class="task-meta">
                    <span>${agentInfo}</span>
                    <span>${lockInfo}</span>
                </div>
            `;
        }
        
        // #COMPLETION_DRIVE_MODAL: Comprehensive task detail modal with tabbed interface and RA data integration
        // Assumption: Modal handles all data loading states and provides complete RA information display
        class TaskDetailModal {
            constructor() {
                this.modal = document.getElementById('taskDetailModal');
                this.currentTask = null;
                this.currentTaskData = null;
                this.raValidations = [];
                this.activeTab = 'overview';
                this.logCursor = null;
                this.filteredLogs = [];
                this.isLoading = false;
                
                this.initializeEventListeners();
            }
            
            initializeEventListeners() {
                // Close button and backdrop click
                const closeBtn = document.getElementById('modalCloseBtn');
                if (closeBtn) {
                    closeBtn.addEventListener('click', () => this.close());
                }
                
                // #COMPLETION_DRIVE_UX: Backdrop click closes modal (standard UX pattern)
                this.modal.addEventListener('click', (e) => {
                    if (e.target === this.modal) {
                        this.close();
                    }
                });
                
                // Escape key closes modal
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && this.modal.style.display === 'flex') {
                        this.close();
                    }
                });
                
                // Tab navigation
                const tabs = document.querySelectorAll('.modal-tab');
                tabs.forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        const tabName = e.target.dataset.tab;
                        this.switchTab(tabName);
                    });
                });
                
                // Log refresh button
                const logRefreshBtn = document.getElementById('logRefreshBtn');
                if (logRefreshBtn) {
                    logRefreshBtn.addEventListener('click', () => {
                        if (this.currentTask) {
                            this.refreshExecutionLogs();
                        }
                    });
                }
                
                // Log type filter
                const logTypeFilter = document.getElementById('logTypeFilter');
                if (logTypeFilter) {
                    logTypeFilter.addEventListener('change', () => {
                        this.filterLogs();
                    });
                }
                
                // RA tags search
                const tagsSearchInput = document.getElementById('tagsSearchInput');
                if (tagsSearchInput) {
                    tagsSearchInput.addEventListener('input', () => {
                        this.filterRATags();
                    });
                }
                
                // System prompt copy button
                const promptCopyBtn = document.getElementById('promptCopyBtn');
                if (promptCopyBtn) {
                    promptCopyBtn.addEventListener('click', () => {
                        this.copySystemPrompt();
                    });
                }
            }
            
            async open(task) {
                if (this.isLoading) return;
                
                this.currentTask = task;
                this.currentTaskData = null;
                this.modal.style.display = 'flex';
                
                // Set basic title immediately
                const titleElement = document.getElementById('modalTaskTitle');
                if (titleElement) {
                    titleElement.textContent = task.name || 'Task Details';
                }
                
                // Show loading state
                this.showLoading();
                
                try {
                    // #COMPLETION_DRIVE_INTEGRATION: Load comprehensive task details from MCP tool
                    // Assumption: get_task_details provides all required data fields
                    await this.loadTaskDetails(task.id);
                    
                    // Hide loading and show content
                    this.hideLoading();
                    
                    // Initialize all tabs with loaded data
                    this.initializeAllTabs();
                    
                } catch (error) {
                    console.error('Failed to load task details:', error);
                    this.hideLoading();
                    this.showError('Failed to load task details');
                }
            }
            
            close() {
                this.modal.style.display = 'none';
                this.currentTask = null;
                this.currentTaskData = null;
                this.activeTab = 'overview';
                this.logCursor = null;
                this.filteredLogs = [];
                
                // Reset tab state
                this.switchTab('overview');
            }
            
            showLoading() {
                this.isLoading = true;
                const loadingElement = document.getElementById('modalLoading');
                if (loadingElement) {
                    loadingElement.style.display = 'flex';
                }
            }
            
            hideLoading() {
                this.isLoading = false;
                const loadingElement = document.getElementById('modalLoading');
                if (loadingElement) {
                    loadingElement.style.display = 'none';
                }
            }
            
            showError(message) {
                // Clear all tab content and show error
                const contentArea = document.querySelector('.modal-content-area');
                if (contentArea) {
                    contentArea.innerHTML = `
                        <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #ef4444;">
                            <div style="text-align: center;">
                                <div style="font-size: 2rem; margin-bottom: 1rem;"></div>
                                <div style="font-size: 1.125rem; font-weight: 600; margin-bottom: 0.5rem;">Error Loading Task</div>
                                <div style="color: #64748b;">${escapeHtml(message)}</div>
                            </div>
                        </div>
                    `;
                }
            }
            
            async loadTaskDetails(taskId) {
                try {
                    // Load task details and RA validations in parallel
                    const [taskResponse, validationsResponse] = await Promise.all([
                        fetch('/api/task/details', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                task_id: String(taskId),
                                log_limit: 100
                            })
                        }),
                        fetch(`/api/assumptions/recent?limit=50`)
                    ]);
                    
                    if (!taskResponse.ok) {
                        throw new Error(`HTTP ${taskResponse.status}: ${taskResponse.statusText}`);
                    }
                    
                    const taskResult = await taskResponse.json();
                    
                    // #SUGGEST_ERROR_HANDLING: Handle MCP tool error responses gracefully
                    if (taskResult.error) {
                        throw new Error(taskResult.error.message || 'Unknown error occurred');
                    }
                    
                    // Parse the MCP tool response (it returns JSON string)
                    if (typeof taskResult.result === 'string') {
                        this.currentTaskData = JSON.parse(taskResult.result);
                    } else {
                        this.currentTaskData = taskResult.result;
                    }
                    
                    // Load RA validations if available and filter for this task
                    this.raValidations = [];
                    if (validationsResponse.ok) {
                        const validationsResult = await validationsResponse.json();
                        const allValidations = validationsResult.validations || [];
                        // Filter to only include validations for this specific task
                        this.raValidations = allValidations.filter(v => v.task_id === parseInt(taskId));
                    }
                    
                    console.log('Loaded task details:', this.currentTaskData);
                    console.log('Loaded RA validations:', this.raValidations);
                    
                } catch (error) {
                    console.error('Error loading task details:', error);
                    throw error;
                }
            }
            
            initializeAllTabs() {
                this.populateOverviewTab();
                this.populateRATagsTab();
                this.populateExecutionLogTab();
                this.populateSystemPromptTab();
                this.populateDependenciesTab();
            }
            
            switchTab(tabName) {
                // Update active tab
                this.activeTab = tabName;
                
                // Update tab buttons
                document.querySelectorAll('.modal-tab').forEach(tab => {
                    tab.classList.remove('active');
                    if (tab.dataset.tab === tabName) {
                        tab.classList.add('active');
                    }
                });
                
                // Update tab content
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                
                const activeContent = document.getElementById(`${tabName}-tab`);
                if (activeContent) {
                    activeContent.classList.add('active');
                }
            }
            
            // #COMPLETION_DRIVE_IMPL: Overview tab population with complete task details and RA metadata
            // Assumption: Task data includes all RA fields and project context from MCP tool
            populateOverviewTab() {
                if (!this.currentTaskData) return;
                
                const task = this.currentTaskData.task;
                const project = this.currentTaskData.project;
                const epic = this.currentTaskData.epic;
                
                // Task description
                const descriptionElement = document.getElementById('taskDescription');
                if (descriptionElement) {
                    descriptionElement.innerHTML = `
                        <h3 style="margin-bottom: 1rem; color: #1e293b;">Description</h3>
                        <p>${escapeHtml(task.description || 'No description available')}</p>
                    `;
                }
                
                // Task metrics
                const metricsElement = document.getElementById('taskMetrics');
                if (metricsElement) {
                    const metrics = [
                        { label: 'Complexity Score', value: (task.ra_score !== null && task.ra_score !== undefined) ? task.ra_score : 'N/A' },
                        { label: 'Estimated Hours', value: (task.ra_metadata?.estimated_hours !== null && task.ra_metadata?.estimated_hours !== undefined) ? task.ra_metadata.estimated_hours : 'N/A' },
                        { label: 'Mode Used', value: task.ra_mode || 'N/A' },
                        { label: 'Current Status', value: task.status || 'Unknown' }
                    ];
                    
                    metricsElement.innerHTML = metrics.map(metric => `
                        <div class="metric-card">
                            <div class="metric-label">${metric.label}</div>
                            <div class="metric-value">${escapeHtml(String(metric.value))}</div>
                        </div>
                    `).join('');
                }
                
                // Project breadcrumb
                const breadcrumbElement = document.getElementById('taskBreadcrumb');
                if (breadcrumbElement) {
                    const breadcrumbParts = [];
                    if (project && project.name) breadcrumbParts.push(project.name);
                    if (epic && epic.name) breadcrumbParts.push(epic.name);
                    breadcrumbParts.push(task.name);
                    
                    breadcrumbElement.innerHTML = `
                        <h4 style="margin-bottom: 0.5rem; color: #1e293b;">Context</h4>
                        <div style="font-size: 0.875rem;">${breadcrumbParts.map(p => escapeHtml(p)).join('  ')}</div>
                    `;
                }
                
                // Timestamps
                const timestampsElement = document.getElementById('taskTimestamps');
                if (timestampsElement) {
                    const timestamps = [
                        { label: 'Created', value: this.formatTimestamp(task.created_at) },
                        { label: 'Updated', value: this.formatTimestamp(task.updated_at) }
                    ];
                    
                    if (task.started_at) {
                        timestamps.push({ label: 'Started', value: this.formatTimestamp(task.started_at) });
                    }
                    
                    if (task.completed_at) {
                        timestamps.push({ label: 'Completed', value: this.formatTimestamp(task.completed_at) });
                    }
                    
                    timestampsElement.innerHTML = `
                        <h4 style="margin-bottom: 1rem; color: #1e293b;">Timeline</h4>
                        ${timestamps.map(ts => `
                            <div class="timestamp-row">
                                <span class="timestamp-label">${ts.label}</span>
                                <span class="timestamp-value">${ts.value}</span>
                            </div>
                        `).join('')}
                    `;
                }
                
                // Status info
                const statusElement = document.getElementById('taskStatus');
                if (statusElement) {
                    const statusInfo = [];
                    
                    if (task.agent_id) {
                        statusInfo.push(`<div><strong>Agent:</strong> ${escapeHtml(task.agent_id)}</div>`);
                    }
                    
                    if (task.lock_holder) {
                        statusInfo.push(`<div><strong>Locked by:</strong> ${escapeHtml(task.lock_holder)}</div>`);
                    }
                    
                    if (task.verification_status) {
                        statusInfo.push(`<div><strong>Verification:</strong> ${escapeHtml(task.verification_status)}</div>`);
                    }
                    
                    statusElement.innerHTML = `
                        <h4 style="margin-bottom: 1rem; color: #1e293b;">Status</h4>
                        ${statusInfo.join('') || '<div style="color: #64748b;">No additional status information</div>'}
                    `;
                }
            }
            
            // #COMPLETION_DRIVE_RA: RA Tags tab with categorized display and search functionality
            // Assumption: RA tags are provided as array with category information
            populateRATagsTab() {
                if (!this.currentTaskData) return;
                
                const task = this.currentTaskData.task;
                const raTags = task.ra_tags || [];
                
                // Create validation status filter buttons
                const categoryFilterElement = document.getElementById('tagsCategoryFilter');
                if (categoryFilterElement) {
                    const statuses = ['All', 'Validated', 'Partial', 'Rejected', 'Pending'];
                    
                    categoryFilterElement.innerHTML = statuses.map(status => `
                        <button class="category-filter-btn ${status === 'All' ? 'active' : ''}" 
                                data-category="${status}">${status}</button>
                    `).join('');
                    
                    // Add status filter event listeners
                    categoryFilterElement.addEventListener('click', (e) => {
                        if (e.target.classList.contains('category-filter-btn')) {
                            // Update active button
                            categoryFilterElement.querySelectorAll('.category-filter-btn').forEach(btn => {
                                btn.classList.remove('active');
                            });
                            e.target.classList.add('active');
                            
                            this.filterRATags();
                        }
                    });
                }
                
                // Add search input event listener
                const searchInput = document.getElementById('tagsSearchInput');
                if (searchInput) {
                    searchInput.addEventListener('input', () => {
                        this.filterRATags();
                    });
                }
                
                this.displayRATagsWithValidations(raTags);
            }
            
            displayRATagsWithValidations(tags) {
                const containerElement = document.getElementById('raTagsContainer');
                if (!containerElement) return;
                
                if (tags.length === 0) {
                    containerElement.innerHTML = `
                        <div style="text-align: center; color: #64748b; padding: 2rem;">
                            <div style="font-size: 3rem; margin-bottom: 1rem;"></div>
                            <div>No RA tags found for this task</div>
                        </div>
                    `;
                    return;
                }
                
                // Process tags with validation information
                const tagData = tags.map(tag => {
                    const tagInfo = this.parseRATag(tag);
                    const tagId = typeof tag === 'object' ? tag.id : null;
                    const validation = tagId ? this.findValidationForTag(tagId) : null;
                    
                    return {
                        ...tagInfo,
                        id: tagId,
                        validation: validation,
                        status: validation ? validation.outcome : 'pending'
                    };
                });
                
                // Group by validation status
                const statusGroups = {
                    'validated': tagData.filter(t => t.status === 'validated'),
                    'partial': tagData.filter(t => t.status === 'partial'), 
                    'rejected': tagData.filter(t => t.status === 'rejected'),
                    'pending': tagData.filter(t => t.status === 'pending')
                };
                
                // Summary stats
                const stats = Object.entries(statusGroups).map(([status, tags]) => 
                    `<span class="ra-stats-item ${status}">${tags.length} ${status}</span>`
                ).join('');
                
                containerElement.innerHTML = `
                    <div class="ra-validation-summary">
                        <h4>Validation Summary</h4>
                        <div class="ra-stats">${stats}</div>
                    </div>
                    
                    ${Object.entries(statusGroups).map(([status, statusTags]) => {
                        if (statusTags.length === 0) return '';
                        
                        return `
                            <div class="ra-status-group">
                                <div class="ra-status-header">
                                    <span class="status-badge ${status}">${status === 'validated' ? 'Validated' : 
                                                                         status === 'rejected' ? 'Rejected' : 
                                                                         status === 'partial' ? 'Partial' : 
                                                                         'Pending'}</span>
                                    <span class="status-count">${statusTags.length} tags</span>
                                </div>
                                <div class="ra-tag-list">
                                    ${statusTags.map(tagData => this.renderRATagWithValidation(tagData)).join('')}
                                </div>
                            </div>
                        `;
                    }).join('')}
                `;
            }
            
            displayRATags(tags) {
                // Keep original method for backward compatibility
                this.displayRATagsWithValidations(tags);
            }
            
            renderRATag(tag) {
                // #SUGGEST_ERROR_HANDLING: Handle different tag data formats gracefully
                let tagName, tagDescription;
                
                if (typeof tag === 'object') {
                    // New format: tag has 'type' and 'text' fields
                    if (tag.type && tag.text) {
                        tagName = tag.type;
                        // Extract description from text (format: "#TYPE: description")
                        const colonIndex = tag.text.indexOf(':');
                        if (colonIndex !== -1) {
                            tagDescription = tag.text.substring(colonIndex + 1).trim();
                        } else {
                            tagDescription = tag.text;
                        }
                    } else {
                        // Fallback to old format
                        tagName = tag.name || tag.tag || 'Unknown Tag';
                        tagDescription = tag.description || tag.content || 'No description';
                    }
                } else {
                    // Parse string format: "#TAG_NAME: Description"
                    const tagString = String(tag);
                    const colonIndex = tagString.indexOf(':');
                    
                    if (colonIndex !== -1) {
                        tagName = tagString.substring(0, colonIndex).trim();
                        tagDescription = tagString.substring(colonIndex + 1).trim();
                    } else {
                        tagName = tagString;
                        tagDescription = 'No description';
                    }
                }
                
                return `
                    <div class="ra-tag-item">
                        <div class="ra-tag-name">${escapeHtml(tagName)}</div>
                        <div class="ra-tag-description">${escapeHtml(tagDescription)}</div>
                    </div>
                `;
            }
            
            parseRATag(tag) {
                let tagName, tagDescription;
                
                if (typeof tag === 'object') {
                    // New format: tag has 'type' and 'text' fields
                    if (tag.type && tag.text) {
                        tagName = tag.type;
                        // Extract description from text (format: "#TYPE: description")
                        const colonIndex = tag.text.indexOf(':');
                        if (colonIndex !== -1) {
                            tagDescription = tag.text.substring(colonIndex + 1).trim();
                        } else {
                            tagDescription = tag.text;
                        }
                    } else {
                        // Fallback to old format
                        tagName = tag.name || tag.tag || 'Unknown Tag';
                        tagDescription = tag.description || tag.content || 'No description';
                    }
                } else {
                    // Parse string format: "#TAG_NAME: Description"
                    const tagString = String(tag);
                    const colonIndex = tagString.indexOf(':');
                    
                    if (colonIndex !== -1) {
                        tagName = tagString.substring(0, colonIndex).trim().replace('#', '');
                        tagDescription = tagString.substring(colonIndex + 1).trim();
                    } else {
                        tagName = tagString.replace('#', '');
                        tagDescription = 'No description';
                    }
                }
                
                // Extract context information if available
                const context = {};
                if (typeof tag === 'object') {
                    // Include context fields from the new RA tag structure
                    if (tag.file_path) context.file_path = tag.file_path;
                    if (tag.line_number) context.line_number = tag.line_number;
                    if (tag.git_branch) context.git_branch = tag.git_branch;
                    if (tag.git_commit) context.git_commit = tag.git_commit;
                    if (tag.language) context.language = tag.language;
                    if (tag.symbol_context) context.symbol_context = tag.symbol_context;
                    if (tag.code_snippet) context.code_snippet = tag.code_snippet;
                    if (tag.created_at) context.created_at = tag.created_at;
                    if (tag.created_by) context.created_by = tag.created_by;
                }
                
                return { name: tagName, description: tagDescription, context: context };
            }
            
            findValidationForTag(tagId) {
                if (!this.raValidations || this.raValidations.length === 0) return null;
                
                // Find validation that matches this exact tag ID
                return this.raValidations.find(validation => 
                    validation.ra_tag_id === tagId
                );
            }
            
            renderRATagWithValidation(tagData) {
                const validation = tagData.validation;
                const statusClass = tagData.status;
                
                return `
                    <div class="ra-tag-item ${statusClass}">
                        <div class="ra-tag-header">
                            <div class="ra-tag-name">${this.escapeHtml(tagData.name)}</div>
                            <span class="validation-status-badge ${statusClass}">
                                ${tagData.status === 'validated' ? 'Validated ' : 
                                  tagData.status === 'rejected' ? 'Rejected ' : 
                                  tagData.status === 'partial' ? 'Partial ~' : 
                                  'Pending...'}
                            </span>
                        </div>
                        <div class="ra-tag-description">${this.escapeHtml(tagData.description)}</div>
                        
                        ${tagData.context && Object.keys(tagData.context).length > 0 ? `
                            <div class="ra-tag-context">
                                ${tagData.context.file_path ? `
                                    <div class="context-item">
                                        <span class="context-label">File:</span>
                                        <span class="context-value file-path">${this.escapeHtml(tagData.context.file_path)}${tagData.context.line_number ? ':' + tagData.context.line_number : ''}</span>
                                    </div>
                                ` : ''}
                                ${tagData.context.git_branch ? `
                                    <div class="context-item">
                                        <span class="context-label">Branch:</span>
                                        <span class="context-value git-info">${this.escapeHtml(tagData.context.git_branch)}${tagData.context.git_commit ? '@' + tagData.context.git_commit.substring(0, 7) : ''}</span>
                                    </div>
                                ` : ''}
                                ${tagData.context.language ? `
                                    <div class="context-item">
                                        <span class="context-label">Lang:</span>
                                        <span class="context-value">${this.escapeHtml(tagData.context.language)}</span>
                                    </div>
                                ` : ''}
                                ${tagData.context.symbol_context ? `
                                    <div class="context-item">
                                        <span class="context-label">Symbol:</span>
                                        <span class="context-value">${this.escapeHtml(tagData.context.symbol_context)}</span>
                                    </div>
                                ` : ''}
                                ${tagData.context.code_snippet ? `
                                    <div class="code-snippet">${this.escapeHtml(tagData.context.code_snippet)}</div>
                                ` : ''}
                            </div>
                        ` : ''}
                        
                        ${validation ? `
                            <div class="validation-details">
                                <div class="validation-summary">
                                    <div class="validation-row">
                                        <span class="validation-label">Confidence:</span>
                                        <span class="confidence-badge">${validation.confidence}%</span>
                                    </div>
                                    <div class="validation-row">
                                        <span class="validation-label">Reviewed by:</span>
                                        <span class="validator-name">${validation.validator_id.replace('mcp-reviewer-agent', 'MCP Reviewer').replace('-', ' ')}</span>
                                    </div>
                                    <div class="validation-row">
                                        <span class="validation-label">Date:</span>
                                        <span class="validation-date">${this.formatTimestamp(validation.validated_at)}</span>
                                    </div>
                                </div>
                                <div class="validation-reasoning">
                                    <div class="reason-label">Validation Notes:</div>
                                    <div class="reason-text">${this.escapeHtml(validation.notes || 'No reason provided')}</div>
                                </div>
                            </div>
                        ` : `
                            <div class="validation-details pending">
                                <div class="validation-reasoning">
                                    <div class="reason-text pending-text">
                                        <em>No validation performed yet</em>
                                    </div>
                                </div>
                            </div>
                        `}
                    </div>
                `;
            }
            
            getTagCategory(tag) {
                const tagName = typeof tag === 'object' ? (tag.name || tag.tag || '') : String(tag);
                
                if (tagName.includes('COMPLETION_DRIVE')) return 'Completion Drive';
                if (tagName.includes('SUGGEST')) return 'Suggestions';
                if (tagName.includes('PATTERN')) return 'Pattern Recognition';
                if (tagName.includes('CONTEXT')) return 'Context Issues';
                if (tagName.includes('CARGO_CULT')) return 'Cargo Cult';
                
                return 'Other';
            }
            
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
            
            filterRATags() {
                if (!this.currentTaskData) return;
                
                const searchInput = document.getElementById('tagsSearchInput');
                const activeStatus = document.querySelector('.category-filter-btn.active');
                
                const searchTerm = searchInput ? searchInput.value.toLowerCase() : '';
                const statusFilter = activeStatus ? activeStatus.dataset.category : 'All';
                
                let tags = this.currentTaskData.task.ra_tags || [];
                
                // Process tags with validation information
                let tagData = tags.map(tag => {
                    const tagInfo = this.parseRATag(tag);
                    const tagId = typeof tag === 'object' ? tag.id : null;
                    const validation = tagId ? this.findValidationForTag(tagId) : null;
                    
                    return {
                        ...tagInfo,
                        id: tagId,
                        validation: validation,
                        status: validation ? validation.outcome : 'pending'
                    };
                });
                
                // Filter by validation status
                if (statusFilter !== 'All') {
                    const filterStatus = statusFilter.toLowerCase();
                    tagData = tagData.filter(tag => tag.status === filterStatus);
                }
                
                // Filter by search term
                if (searchTerm) {
                    tagData = tagData.filter(tag => {
                        return tag.name.toLowerCase().includes(searchTerm) || 
                               tag.description.toLowerCase().includes(searchTerm) ||
                               (tag.validation && tag.validation.notes && tag.validation.notes.toLowerCase().includes(searchTerm));
                    });
                }
                
                // Rebuild the display with filtered data
                this.displayFilteredTags(tagData);
            }
            
            displayFilteredTags(tagData) {
                const containerElement = document.getElementById('raTagsContainer');
                if (!containerElement) return;
                
                if (tagData.length === 0) {
                    containerElement.innerHTML = `
                        <div style="text-align: center; color: #64748b; padding: 2rem;">
                            <div style="font-size: 3rem; margin-bottom: 1rem;"></div>
                            <div>No tags match the current filter</div>
                        </div>
                    `;
                    return;
                }
                
                containerElement.innerHTML = `
                    <div class="ra-tag-list">
                        ${tagData.map(tagData => this.renderRATagWithValidation(tagData)).join('')}
                    </div>
                `;
            }
            
            // #COMPLETION_DRIVE_IMPL: Execution Log tab with timeline display and filtering
            // Assumption: Logs are provided in chronological order with different types
            populateExecutionLogTab() {
                if (!this.currentTaskData) return;
                
                const logs = this.currentTaskData.logs || [];
                this.filteredLogs = [...logs]; // Initialize filtered logs
                
                this.displayExecutionLogs();
                this.updateLogPagination();
            }
            
            displayExecutionLogs() {
                const containerElement = document.getElementById('executionLogContainer');
                if (!containerElement) return;
                
                if (this.filteredLogs.length === 0) {
                    containerElement.innerHTML = `
                        <div style="text-align: center; color: #64748b; padding: 2rem;">
                            <div style="font-size: 3rem; margin-bottom: 1rem;"></div>
                            <div>No execution logs found</div>
                        </div>
                    `;
                    return;
                }
                
                containerElement.innerHTML = this.filteredLogs.map(log => this.renderLogEntry(log)).join('');
            }
            
            renderLogEntry(log) {
                const logType = log.kind || log.type || 'update';
                const timestamp = this.formatTimestamp(log.ts || log.timestamp || log.created_at);
                
                // Extract content from payload or other fields
                let content = 'No content';
                if (log.payload) {
                    if (typeof log.payload === 'string') {
                        content = log.payload;
                    } else if (typeof log.payload === 'object') {
                        // Format payload object for display
                        if (log.payload.agent_action) {
                            content = `Action: ${log.payload.agent_action}`;
                            if (log.payload.original_parameters) {
                                const params = log.payload.original_parameters;
                                if (params.name) content += ` - Task: ${params.name}`;
                                if (params.ra_mode) content += ` (${params.ra_mode})`;
                                if (params.ra_score) content += ` [Score: ${params.ra_score}]`;
                            }
                        } else if (log.payload.prompt_snapshot) {
                            content = 'System prompt snapshot captured';
                        } else {
                            content = JSON.stringify(log.payload, null, 2);
                        }
                    }
                } else {
                    content = log.content || log.message || log.data || 'No content';
                }
                
                return `
                    <div class="log-entry ${logType}">
                        <div class="log-entry-header">
                            <span class="log-entry-type ${logType}">${logType}</span>
                            <span class="log-entry-timestamp">${timestamp}</span>
                        </div>
                        <div class="log-entry-content">${escapeHtml(content)}</div>
                    </div>
                `;
            }
            
            filterLogs() {
                if (!this.currentTaskData) return;
                
                const filterSelect = document.getElementById('logTypeFilter');
                const filterValue = filterSelect ? filterSelect.value : 'all';
                
                const allLogs = this.currentTaskData.logs || [];
                
                if (filterValue === 'all') {
                    this.filteredLogs = [...allLogs];
                } else {
                    this.filteredLogs = allLogs.filter(log => {
                        const logType = log.kind || log.type || 'update';
                        return logType === filterValue;
                    });
                }
                
                this.displayExecutionLogs();
                this.updateLogPagination();
            }
            
            updateLogPagination() {
                const paginationElement = document.getElementById('logPagination');
                if (paginationElement) {
                    const pagination = this.currentTaskData.pagination || {};
                    paginationElement.innerHTML = `
                        <span style="font-size: 0.875rem; color: #64748b;">
                            ${this.filteredLogs.length} entries
                            ${pagination.has_more ? ' (more available)' : ''}
                        </span>
                        ${pagination.has_more ? `
                            <button class="pagination-btn" onclick="taskDetailModal.loadMoreLogs()">Load More</button>
                        ` : ''}
                    `;
                }
            }
            
            async refreshExecutionLogs() {
                if (!this.currentTask) return;
                
                try {
                    this.showLoading();
                    await this.loadTaskDetails(this.currentTask.id);
                    this.hideLoading();
                    this.populateExecutionLogTab();
                } catch (error) {
                    this.hideLoading();
                    console.error('Failed to refresh logs:', error);
                    showNotification('Failed to refresh logs', 'error');
                }
            }
            
            async loadMoreLogs() {
                // #SUGGEST_EDGE_CASE: Implement pagination for large log histories
                // This would require additional API calls with cursor-based pagination
                console.log('Load more logs not yet implemented');
                showNotification('Log pagination not yet implemented', 'info');
            }
            
            // #COMPLETION_DRIVE_IMPL: System Prompt tab with syntax highlighting display
            // Assumption: prompt_snapshot field contains the system prompt text
            populateSystemPromptTab() {
                if (!this.currentTaskData) return;
                
                const task = this.currentTaskData.task;
                const promptSnapshot = task.prompt_snapshot || '';
                
                // Prompt version info
                const versionElement = document.getElementById('promptVersion');
                if (versionElement) {
                    const versionInfo = task.prompt_version || 'Unknown Version';
                    versionElement.textContent = `Version: ${versionInfo}`;
                }
                
                // System prompt content
                const contentElement = document.getElementById('systemPromptContent');
                if (contentElement) {
                    if (promptSnapshot) {
                        contentElement.textContent = promptSnapshot;
                    } else {
                        contentElement.innerHTML = `<span style="color: #64748b; font-style: italic;">No system prompt available</span>`;
                    }
                }
            }
            
            copySystemPrompt() {
                const contentElement = document.getElementById('systemPromptContent');
                if (contentElement && contentElement.textContent.trim()) {
                    navigator.clipboard.writeText(contentElement.textContent).then(() => {
                        showNotification('System prompt copied to clipboard', 'success');
                    }).catch((error) => {
                        console.error('Failed to copy prompt:', error);
                        showNotification('Failed to copy prompt', 'error');
                    });
                } else {
                    showNotification('No prompt to copy', 'info');
                }
            }
            
            // #COMPLETION_DRIVE_IMPL: Dependencies tab with task relationship visualization
            // Assumption: Dependencies are resolved to task summaries with status information
            populateDependenciesTab() {
                if (!this.currentTaskData) return;
                
                const dependencies = this.currentTaskData.dependencies || [];
                
                // Dependency statistics
                const statsElement = document.getElementById('dependencyStats');
                if (statsElement) {
                    const stats = this.calculateDependencyStats(dependencies);
                    
                    statsElement.innerHTML = Object.entries(stats).map(([status, count]) => `
                        <div class="dependency-stat">
                            <div class="metric-label">${status.replace('_', ' ').toUpperCase()}</div>
                            <div class="metric-value">${count}</div>
                        </div>
                    `).join('');
                }
                
                // Dependencies list
                const containerElement = document.getElementById('dependenciesContainer');
                if (containerElement) {
                    if (dependencies.length === 0) {
                        containerElement.innerHTML = `
                            <div style="text-align: center; color: #64748b; padding: 2rem;">
                                <div style="font-size: 3rem; margin-bottom: 1rem;"></div>
                                <div>No dependencies for this task</div>
                            </div>
                        `;
                    } else {
                        containerElement.innerHTML = dependencies.map(dep => this.renderDependencyItem(dep)).join('');
                    }
                }
            }
            
            renderDependencyItem(dependency) {
                const depId = dependency.id || dependency.task_id || 'Unknown';
                const depName = dependency.name || dependency.task_name || 'Unnamed Task';
                const depStatus = (dependency.status || 'unknown').toLowerCase();
                
                return `
                    <div class="dependency-item" onclick="taskDetailModal.openDependencyTask(${depId})">
                        <div class="dependency-info">
                            <div class="dependency-name">${escapeHtml(depName)}</div>
                            <div class="dependency-id">Task #${depId}</div>
                        </div>
                        <div class="dependency-status ${depStatus}">${depStatus.replace('_', ' ')}</div>
                    </div>
                `;
            }
            
            calculateDependencyStats(dependencies) {
                const stats = { todo: 0, in_progress: 0, review: 0, done: 0 };
                
                dependencies.forEach(dep => {
                    // Use the same mapping function as the main task counts
                    const statusKey = mapDatabaseStatusToUI(dep.status || 'pending');
                    if (stats.hasOwnProperty(statusKey)) {
                        stats[statusKey]++;
                    }
                });
                
                return stats;
            }
            
            openDependencyTask(taskId) {
                // #SUGGEST_EDGE_CASE: Handle circular dependencies gracefully
                console.log(`Opening dependency task ${taskId}`);
                
                // Find the task in our current state
                const dependencyTask = AppState.tasks.get(String(taskId));
                if (dependencyTask) {
                    // Close current modal and open new one
                    this.close();
                    setTimeout(() => {
                        openTaskDetailModal(dependencyTask);
                    }, 100);
                } else {
                    showNotification('Dependency task not found in current view', 'error');
                }
            }
            
            // Utility method for timestamp formatting
            formatTimestamp(timestamp) {
                if (!timestamp) return 'N/A';
                
                try {
                    // Handle various timestamp formats
                    let cleanTimestamp = timestamp;
                    if (typeof timestamp === 'string') {
                        // Handle format like "2025-09-09T22:17:18.852152+00:00Z" - remove Z after timezone
                        cleanTimestamp = timestamp.replace(/\+00:00Z$/, '+00:00');
                        // Handle format ending with just 'Z'
                        cleanTimestamp = cleanTimestamp.replace(/Z$/, '');
                        // Handle microseconds - truncate to milliseconds for better browser compatibility
                        cleanTimestamp = cleanTimestamp.replace(/\.\d{6}/, function(match) {
                            return match.substring(0, 4); // Keep only 3 digits after decimal
                        });
                    }
                    
                    const date = new Date(cleanTimestamp);
                    
                    // Validate the date is actually valid
                    if (isNaN(date.getTime())) {
                        console.warn('Invalid timestamp format:', timestamp, 'cleaned to:', cleanTimestamp);
                        return 'Invalid Date';
                    }
                    
                    return date.toLocaleString('en-US', {
                        year: 'numeric',
                        month: 'short',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                } catch (error) {
                    console.error('Error formatting timestamp:', timestamp, error);
                    return 'Invalid Date';
                }
            }
        }
        
        // Enhanced Interactive Knowledge Management Modal
        // Full-featured modal with Add/Edit/Delete functionality, form validation, and API integration
        class KnowledgeManagementModal {
            constructor() {
                this.modal = document.getElementById('knowledgeModal');
                this.isOpen = false;
                this.isEditing = false;
                this.currentEditingItem = null;
                this.originalData = {};
                this.currentTags = [];
                this.hasUnsavedChanges = false;
                this.knowledgeItems = [];
                this.sessionProject = null;
                this.currentInlineEditItem = null;
                this.sessionEpic = null;
                
                this.initializeEventListeners();
            }
            
            initializeEventListeners() {
                // Core modal functionality
                this.setupCloseHandlers();
                
                // Interactive action buttons
                this.setupActionButtons();
                
                // Form functionality
                this.setupFormHandlers();
                
                // Search and filtering
                this.setupSearchAndFiltering();
                
                // Confirmation dialog
                this.setupConfirmationDialog();
            }
            
            setupCloseHandlers() {
                const closeBtn = document.getElementById('knowledgeModalCloseBtn');
                if (closeBtn) {
                    closeBtn.addEventListener('click', () => this.handleClose());
                }
                
                this.modal?.addEventListener('click', (e) => {
                    if (e.target === this.modal) {
                        this.handleClose();
                    }
                });
                
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && this.isOpen) {
                        this.handleClose();
                    }
                });
            }
            
            setupActionButtons() {
                // Add New button
                document.getElementById('addKnowledgeBtn')?.addEventListener('click', () => {
                    this.startAddingNew();
                });
                
                // Save button
                document.getElementById('saveKnowledgeBtn')?.addEventListener('click', () => {
                    this.saveKnowledgeItem();
                });
                
                // Cancel button
                document.getElementById('cancelKnowledgeBtn')?.addEventListener('click', () => {
                    this.cancelEditing();
                });
            }
            
            setupFormHandlers() {
                // Character counter for content textarea
                const contentTextarea = document.getElementById('itemContent');
                const charCounter = document.getElementById('contentCharCounter');
                contentTextarea?.addEventListener('input', (e) => {
                    const count = e.target.value.length;
                    charCounter.textContent = `${count}/2000`;
                    this.hasUnsavedChanges = true;
                    this.validateField('content', e.target.value);
                });
                
                // Tags input handler
                const tagsInput = document.getElementById('itemTags');
                tagsInput?.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        this.addTag(e.target.value.trim());
                        e.target.value = '';
                    }
                });
                
                // Form field validation
                ['itemTitle', 'itemCategory', 'itemContent'].forEach(fieldId => {
                    const field = document.getElementById(fieldId);
                    field?.addEventListener('input', (e) => {
                        this.hasUnsavedChanges = true;
                        this.validateField(fieldId.replace('item', '').toLowerCase(), e.target.value);
                    });
                });
            }
            
            setupSearchAndFiltering() {
                const searchInput = document.getElementById('knowledgeSearchInput');
                const clearSearchBtn = document.getElementById('clearSearchBtn');
                const categoryFilter = document.getElementById('categoryFilter');
                
                // Search with debouncing
                let searchTimeout;
                searchInput?.addEventListener('input', (e) => {
                    const value = e.target.value;
                    clearSearchBtn.style.display = value ? 'block' : 'none';
                    
                    clearTimeout(searchTimeout);
                    searchTimeout = setTimeout(() => {
                        this.performSearch(value.toLowerCase());
                    }, 300);
                });
                
                // Clear search
                clearSearchBtn?.addEventListener('click', () => {
                    searchInput.value = '';
                    clearSearchBtn.style.display = 'none';
                    this.performSearch('');
                });
                
                // Category filtering
                categoryFilter?.addEventListener('change', (e) => {
                    this.filterByCategory(e.target.value);
                });
            }
            
            setupConfirmationDialog() {
                const dialog = document.getElementById('confirmationDialog');
                const confirmBtn = document.getElementById('confirmationConfirmBtn');
                const cancelBtn = document.getElementById('confirmationCancelBtn');
                
                confirmBtn?.addEventListener('click', () => {
                    if (this.pendingAction) {
                        this.pendingAction();
                        this.pendingAction = null;
                    }
                    dialog.style.display = 'none';
                });
                
                cancelBtn?.addEventListener('click', () => {
                    this.pendingAction = null;
                    dialog.style.display = 'none';
                });
            }
            
            async open() {
                if (!this.modal) return;
                
                this.modal.style.display = 'flex';
                this.isOpen = true;
                
                // Update context indicator
                this.updateContextIndicator();
                
                // Load knowledge data
                this.showLoading(true);
                await this.loadKnowledgeData();
                this.showLoading(false);
                
                // Focus management
                const firstFocusable = this.modal.querySelector('button, input, select, textarea, [tabindex]:not([tabindex="-1"])');
                if (firstFocusable) {
                    setTimeout(() => firstFocusable.focus(), 100);
                }
                
                document.body.style.overflow = 'hidden';
                console.log('Knowledge Management modal opened');
            }
            
            async handleClose() {
                if (this.hasUnsavedChanges) {
                    const confirmed = await this.showConfirmation(
                        'Unsaved Changes',
                        'You have unsaved changes. Are you sure you want to close without saving?'
                    );
                    if (!confirmed) return;
                }
                
                this.close();
            }
            
            close() {
                if (!this.modal) return;
                
                this.modal.style.display = 'none';
                this.isOpen = false;
                this.resetForm();
                
                // Reset session context when closing
                this.sessionProject = null;
                this.sessionEpic = null;
                this.knowledgeItems = [];
                
                document.body.style.overflow = '';
                
                const knowledgeBtn = document.getElementById('knowledgeBtn');
                knowledgeBtn?.focus();
                
                console.log('Knowledge Management modal closed');
            }
            
            updateContextIndicator() {
                const indicator = document.getElementById('knowledgeContextIndicator');
                const projectSelector = document.getElementById('projectSelector');
                const epicSelector = document.getElementById('epicSelector');
                
                const currentProject = projectSelector?.value || 1;
                const currentEpic = epicSelector?.value;
                
                let contextText = 'All Projects';
                if (currentProject && currentEpic) {
                    contextText = `Project ${currentProject} - Epic ${currentEpic}`;
                } else if (currentProject) {
                    contextText = `Project ${currentProject}`;
                }
                
                if (indicator) {
                    indicator.textContent = contextText;
                }
            }
            
            startAddingNew() {
                this.isEditing = true;
                this.currentEditingItem = null;
                this.showEditForm(true);
                this.resetForm();
                
                document.getElementById('formTitle').textContent = 'Add New Knowledge Item';
                document.getElementById('itemTitle').focus();
            }
            
            startEditing(knowledgeId) {
                const item = this.findKnowledgeItemById(knowledgeId);
                if (!item) return;
                
                this.isEditing = true;
                this.currentEditingItem = item;
                this.originalData = { ...item };
                this.showEditForm(true);
                this.populateForm(item);
                
                document.getElementById('formTitle').textContent = 'Edit Knowledge Item';
            }
            
            populateForm(item) {
                document.getElementById('itemTitle').value = item.title || '';
                document.getElementById('itemCategory').value = item.category || '';
                document.getElementById('itemContent').value = item.content || '';
                document.getElementById('itemPriority').value = item.priority || 2;
                
                // Handle tags
                this.currentTags = Array.isArray(item.tags) ? [...item.tags] : [];
                this.renderTags();
                
                // Update character counter
                const content = item.content || '';
                document.getElementById('contentCharCounter').textContent = `${content.length}/2000`;
            }
            
            showEditForm(show) {
                const form = document.getElementById('knowledgeEditForm');
                const saveBtn = document.getElementById('saveKnowledgeBtn');
                const cancelBtn = document.getElementById('cancelKnowledgeBtn');
                
                if (show) {
                    form.style.display = 'block';
                    saveBtn.style.display = 'inline-flex';
                    cancelBtn.style.display = 'inline-flex';
                } else {
                    form.style.display = 'none';
                    saveBtn.style.display = 'none';
                    cancelBtn.style.display = 'none';
                }
            }
            
            async saveKnowledgeItem() {
                console.log('saveKnowledgeItem called');
                
                if (!this.validateForm()) {
                    console.log('Form validation failed');
                    return;
                }
                
                const formData = this.getFormData();
                console.log('Form data:', formData);
                
                try {
                    console.log('Sending PUT request to /api/knowledge');
                    const response = await fetch('/api/knowledge', {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(formData)
                    });
                    
                    console.log('Response status:', response.status);
                    const result = await response.json();
                    console.log('Response result:', result);
                    
                    if (result.success) {
                        showNotification('Knowledge item saved successfully!', 'success');
                        this.hasUnsavedChanges = false;
                        this.cancelEditing();
                        await this.loadKnowledgeData(); // Refresh the list
                    } else {
                        showNotification(result.message || 'Failed to save knowledge item', 'error');
                    }
                } catch (error) {
                    console.error('Error saving knowledge item:', error);
                    showNotification('Error saving knowledge item', 'error');
                }
            }
            
            getFormData() {
                const projectSelector = document.getElementById('projectSelector');
                const epicSelector = document.getElementById('epicSelector');
                
                // Ensure project_id is always provided (required by database schema)
                const projectId = projectSelector?.value || this.sessionProject || 1;
                const epicId = epicSelector?.value || this.sessionEpic || null;
                
                return {
                    knowledge_id: this.currentEditingItem?.id || null,
                    title: document.getElementById('itemTitle').value.trim(),
                    content: document.getElementById('itemContent').value.trim(),
                    category: document.getElementById('itemCategory').value,
                    tags: this.currentTags,
                    priority: parseInt(document.getElementById('itemPriority').value),
                    project_id: parseInt(projectId), // Ensure it's always an integer
                    epic_id: epicId ? parseInt(epicId) : null,
                    is_active: true
                };
            }
            
            validateForm() {
                console.log('validateForm called');
                let isValid = true;
                
                const title = document.getElementById('itemTitle').value.trim();
                const category = document.getElementById('itemCategory').value;
                const content = document.getElementById('itemContent').value.trim();
                
                console.log('Form values:', { title, category, content });
                
                isValid = this.validateField('title', title) && isValid;
                isValid = this.validateField('category', category) && isValid;
                isValid = this.validateField('content', content) && isValid;
                
                console.log('Form validation result:', isValid);
                return isValid;
            }
            
            validateField(fieldName, value) {
                const errorElement = document.getElementById(`${fieldName}Error`);
                let errorMessage = '';
                
                switch (fieldName) {
                    case 'title':
                        if (!value.trim()) {
                            errorMessage = 'Title is required';
                        } else if (value.length > 200) {
                            errorMessage = 'Title must be 200 characters or less';
                        }
                        break;
                    case 'category':
                        if (!value) {
                            errorMessage = 'Category is required';
                        }
                        break;
                    case 'content':
                        if (!value.trim()) {
                            errorMessage = 'Content is required';
                        } else if (value.length > 2000) {
                            errorMessage = 'Content must be 2000 characters or less';
                        }
                        break;
                }
                
                if (errorElement) {
                    errorElement.textContent = errorMessage;
                }
                
                return !errorMessage;
            }
            
            addTag(tagText) {
                if (tagText && !this.currentTags.includes(tagText)) {
                    this.currentTags.push(tagText);
                    this.renderTags();
                    this.hasUnsavedChanges = true;
                }
            }
            
            removeTag(tagText) {
                this.currentTags = this.currentTags.filter(tag => tag !== tagText);
                this.renderTags();
                this.hasUnsavedChanges = true;
            }
            
            renderTags() {
                const tagsDisplay = document.getElementById('tagsDisplay');
                if (!tagsDisplay) return;
                
                tagsDisplay.innerHTML = this.currentTags.map(tag => `
                    <div class="tag-item">
                        ${tag}
                        <button class="tag-remove" onclick="knowledgeModal.removeTag('${tag}')" type="button"></button>
                    </div>
                `).join('');
            }
            
            cancelEditing() {
                this.isEditing = false;
                this.currentEditingItem = null;
                this.hasUnsavedChanges = false;
                this.showEditForm(false);
                this.resetForm();
            }
            
            resetForm() {
                document.getElementById('itemTitle').value = '';
                document.getElementById('itemCategory').value = '';
                document.getElementById('itemContent').value = '';
                document.getElementById('itemPriority').value = '2';
                document.getElementById('itemTags').value = '';
                document.getElementById('contentCharCounter').textContent = '0/2000';
                
                this.currentTags = [];
                this.renderTags();
                
                // Clear error messages
                ['titleError', 'categoryError', 'contentError'].forEach(errorId => {
                    const errorElement = document.getElementById(errorId);
                    if (errorElement) errorElement.textContent = '';
                });
            }
            
            async deleteKnowledgeItem(knowledgeId) {
                const item = this.findKnowledgeItemById(knowledgeId);
                if (!item) return;
                
                const confirmed = await this.showConfirmation(
                    'Delete Knowledge Item',
                    `Are you sure you want to delete "${item.title}"? This action cannot be undone.`
                );
                
                if (!confirmed) return;
                
                try {
                    const response = await fetch(`/api/knowledge/${knowledgeId}`, {
                        method: 'DELETE',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    const result = await response.json();
                    
                    if (response.ok && result.success) {
                        showNotification(`"${item.title}" deleted successfully`, 'success');
                        // Refresh the knowledge list to remove the deleted item
                        await this.loadKnowledgeData();
                    } else {
                        const errorMsg = result.error || result.message || 'Failed to delete knowledge item';
                        showNotification(errorMsg, 'error');
                    }
                    
                } catch (error) {
                    console.error('Error deleting knowledge item:', error);
                    showNotification('Error deleting knowledge item', 'error');
                }
            }
            
            // Inline editing methods
            startInlineEditing(knowledgeId) {
                // Cancel any existing inline edit
                if (this.currentInlineEditItem) {
                    this.cancelInlineEditing();
                }
                
                const item = this.findKnowledgeItemById(knowledgeId);
                if (!item) return;
                
                this.currentInlineEditItem = { ...item };
                // Re-render the items to show the inline edit form
                this.renderKnowledgeItems(this.knowledgeItems);
            }
            
            renderInlineEditForm(item) {
                const tagsList = (item.tags || []).join(', ');
                
                return `
                    <div class="knowledge-item inline-edit-item" data-knowledge-id="${item.id}">
                        <div class="inline-edit-form">
                            <div class="inline-form-header">
                                <h4>Edit Knowledge Item</h4>
                                <div class="inline-form-actions">
                                    <button class="inline-action-btn save-btn" title="Save Changes" onclick="knowledgeModal.saveInlineEdit(${item.id})">
                                        <svg width="12" height="12" fill="currentColor" viewBox="0 0 16 16">
                                            <path d="M2 1a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H9.5a1 1 0 0 0-1 1v7.293l2.646-2.647a.5.5 0 0 1 .708.708l-3.5 3.5a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L8.5 8.293V2a2 2 0 0 1 2-2H14a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h2.5a.5.5 0 0 1 0 1H2z"/>
                                        </svg>
                                        Save
                                    </button>
                                    <button class="inline-action-btn cancel-btn" title="Cancel Changes" onclick="knowledgeModal.cancelInlineEditing()">
                                        <svg width="12" height="12" fill="currentColor" viewBox="0 0 16 16">
                                            <path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z"/>
                                        </svg>
                                        Cancel
                                    </button>
                                </div>
                            </div>
                            <div class="inline-form-grid">
                                <div class="inline-form-group">
                                    <label>Title</label>
                                    <input type="text" id="inline-title-${item.id}" value="${item.title}" maxlength="200" class="inline-form-input">
                                </div>
                                <div class="inline-form-group">
                                    <label>Category</label>
                                    <select id="inline-category-${item.id}" class="inline-form-select">
                                        <option value="Technical Documentation" ${item.category === 'Technical Documentation' ? 'selected' : ''}>Technical Documentation</option>
                                        <option value="Best Practices" ${item.category === 'Best Practices' ? 'selected' : ''}>Best Practices</option>
                                        <option value="Development Workflow" ${item.category === 'Development Workflow' ? 'selected' : ''}>Development Workflow</option>
                                        <option value="Troubleshooting" ${item.category === 'Troubleshooting' ? 'selected' : ''}>Troubleshooting</option>
                                        <option value="Architecture" ${item.category === 'Architecture' ? 'selected' : ''}>Architecture</option>
                                        <option value="Standards" ${item.category === 'Standards' ? 'selected' : ''}>Standards</option>
                                    </select>
                                </div>
                                <div class="inline-form-group full-width">
                                    <label>Content</label>
                                    <textarea id="inline-content-${item.id}" rows="4" maxlength="2000" class="inline-form-textarea">${item.content}</textarea>
                                </div>
                                <div class="inline-form-group">
                                    <label>Tags (comma separated)</label>
                                    <input type="text" id="inline-tags-${item.id}" value="${tagsList}" class="inline-form-input">
                                </div>
                                <div class="inline-form-group">
                                    <label>Priority</label>
                                    <select id="inline-priority-${item.id}" class="inline-form-select">
                                        <option value="1" ${item.priority == 1 ? 'selected' : ''}>Low</option>
                                        <option value="2" ${item.priority == 2 ? 'selected' : ''}>Medium</option>
                                        <option value="3" ${item.priority == 3 ? 'selected' : ''}>High</option>
                                        <option value="4" ${item.priority == 4 ? 'selected' : ''}>Critical</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            async saveInlineEdit(knowledgeId) {
                try {
                    const title = document.getElementById(`inline-title-${knowledgeId}`).value.trim();
                    const category = document.getElementById(`inline-category-${knowledgeId}`).value;
                    const content = document.getElementById(`inline-content-${knowledgeId}`).value.trim();
                    const tagsValue = document.getElementById(`inline-tags-${knowledgeId}`).value.trim();
                    const priority = parseInt(document.getElementById(`inline-priority-${knowledgeId}`).value);
                    
                    // Parse tags
                    const tags = tagsValue ? tagsValue.split(',').map(tag => tag.trim()).filter(tag => tag) : [];
                    
                    // Validate required fields
                    if (!title) {
                        showNotification('Title is required', 'error');
                        return;
                    }
                    if (!content) {
                        showNotification('Content is required', 'error');
                        return;
                    }
                    
                    const response = await fetch('/api/knowledge', {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            knowledge_id: knowledgeId,
                            title: title,
                            category: category,
                            content: content,
                            tags: tags,
                            priority: priority
                        })
                    });
                    
                    const result = await response.json();
                    
                    if (response.ok && result.success) {
                        showNotification('Knowledge item updated successfully!', 'success');
                        this.currentInlineEditItem = null;
                        await this.loadKnowledgeData();
                    } else {
                        const errorMsg = result.error || result.message || 'Failed to update knowledge item';
                        showNotification(errorMsg, 'error');
                    }
                    
                } catch (error) {
                    console.error('Error saving inline edit:', error);
                    showNotification('Error updating knowledge item', 'error');
                }
            }
            
            cancelInlineEditing() {
                this.currentInlineEditItem = null;
                // Re-render to show normal view
                this.renderKnowledgeItems(this.knowledgeItems);
            }
            
            async showConfirmation(title, message) {
                return new Promise((resolve) => {
                    const dialog = document.getElementById('confirmationDialog');
                    const titleElement = document.getElementById('confirmationTitle');
                    const messageElement = document.getElementById('confirmationMessage');
                    
                    titleElement.textContent = title;
                    messageElement.textContent = message;
                    dialog.style.display = 'flex';
                    
                    this.pendingAction = () => resolve(true);
                    
                    // Handle cancel
                    const cancelBtn = document.getElementById('confirmationCancelBtn');
                    cancelBtn.onclick = () => {
                        dialog.style.display = 'none';
                        resolve(false);
                    };
                });
            }

            // Knowledge logs functionality
            async toggleKnowledgeLogs(knowledgeId) {
                const toggleBtn = document.querySelector(`[onclick="knowledgeModal.toggleKnowledgeLogs(${knowledgeId})"]`);
                const logsContainer = document.getElementById(`logs-${knowledgeId}`);
                
                if (!toggleBtn || !logsContainer) return;
                
                const isExpanded = logsContainer.classList.contains('expanded');
                
                if (isExpanded) {
                    // Collapse the logs
                    logsContainer.classList.remove('expanded');
                    toggleBtn.classList.remove('expanded');
                } else {
                    // Expand and load logs
                    logsContainer.classList.add('expanded');
                    toggleBtn.classList.add('expanded');
                    
                    // Load logs if not already loaded
                    if (logsContainer.querySelector('.logs-loading')) {
                        await this.loadKnowledgeLogs(knowledgeId);
                    }
                }
            }

            async loadKnowledgeLogs(knowledgeId) {
                const logsContainer = document.getElementById(`logs-${knowledgeId}`);
                if (!logsContainer) return;
                
                try {
                    const response = await fetch(`/api/knowledge/${knowledgeId}/logs?limit=10`);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    
                    const data = await response.json();
                    
                    if (data.success && data.logs && data.logs.length > 0) {
                        this.renderKnowledgeLogs(knowledgeId, data.logs);
                    } else {
                        this.renderEmptyLogs(knowledgeId);
                    }
                    
                } catch (error) {
                    console.error('Error loading knowledge logs:', error);
                    this.renderErrorLogs(knowledgeId);
                }
            }

            renderKnowledgeLogs(knowledgeId, logs) {
                const logsContainer = document.getElementById(`logs-${knowledgeId}`);
                if (!logsContainer) return;
                
                const logsHtml = logs.map(log => this.renderSingleKnowledgeLog(log)).join('');
                logsContainer.innerHTML = logsHtml;
            }

            renderSingleKnowledgeLog(log) {
                const timestamp = this.formatTimestamp(log.created_at);
                const actionType = log.action_type || 'activity';
                const reason = log.change_reason || 'No details provided';
                const user = log.created_by || 'Unknown';
                
                return `
                    <div class="knowledge-log-entry">
                        <div class="knowledge-log-header">
                            <span class="knowledge-log-type">${actionType}</span>
                            <span class="knowledge-log-timestamp">${timestamp}</span>
                        </div>
                        <div class="knowledge-log-content">${escapeHtml(reason)}</div>
                        <div class="knowledge-log-user">by ${escapeHtml(user)}</div>
                    </div>
                `;
            }

            renderEmptyLogs(knowledgeId) {
                const logsContainer = document.getElementById(`logs-${knowledgeId}`);
                if (!logsContainer) return;
                
                logsContainer.innerHTML = '<div class="logs-empty">No activity logs found</div>';
            }

            renderErrorLogs(knowledgeId) {
                const logsContainer = document.getElementById(`logs-${knowledgeId}`);
                if (!logsContainer) return;
                
                logsContainer.innerHTML = '<div class="logs-empty">Error loading activity logs</div>';
            }

            // Refresh logs for a specific knowledge item (called by WebSocket handler)
            async refreshKnowledgeLogs(knowledgeId) {
                const logsContainer = document.getElementById(`logs-${knowledgeId}`);
                if (!logsContainer || !logsContainer.classList.contains('expanded')) {
                    return; // Don't refresh if logs aren't currently visible
                }
                
                await this.loadKnowledgeLogs(knowledgeId);
            }
            
            showLoading(show) {
                const loadingState = document.getElementById('loadingState');
                const container = document.getElementById('knowledgeItemsContainer');
                
                if (show) {
                    loadingState.style.display = 'flex';
                    container.style.display = 'none';
                } else {
                    loadingState.style.display = 'none';
                    container.style.display = 'block';
                }
            }
            
            async loadKnowledgeData(forceProjectId = null, forceEpicId = null) {
                try {
                    const projectSelector = document.getElementById('projectSelector');
                    const epicSelector = document.getElementById('epicSelector');
                    const currentProject = forceProjectId || projectSelector?.value || 1;
                    const currentEpic = forceEpicId || epicSelector?.value;
                    
                    // Store the project/epic context for this modal session
                    if (!this.sessionProject) {
                        this.sessionProject = currentProject;
                        this.sessionEpic = currentEpic;
                    }
                    
                    let apiUrl;
                    if (this.sessionEpic && this.sessionProject) {
                        apiUrl = `/api/knowledge/epic/${this.sessionProject}/${this.sessionEpic}`;
                    } else if (this.sessionProject) {
                        apiUrl = `/api/knowledge/project/${this.sessionProject}`;
                    } else {
                        apiUrl = `/api/knowledge/project/1`;
                    }
                    
                    const response = await fetch(apiUrl);
                    const data = await response.json();
                    
                    if (data.success && data.knowledge_items) {
                        this.renderKnowledgeItems(data.knowledge_items);
                    } else {
                        this.renderEmptyState();
                    }
                } catch (error) {
                    console.error('Error loading knowledge data:', error);
                    this.renderErrorState();
                }
            }
            
            renderKnowledgeItems(knowledgeItems) {
                const container = document.getElementById('knowledgeItemsContainer');
                
                // Store the knowledge items for later use
                this.knowledgeItems = knowledgeItems;
                
                if (knowledgeItems.length === 0) {
                    this.renderEmptyState();
                    return;
                }
                
                // Group by category
                const groupedItems = knowledgeItems.reduce((groups, item) => {
                    const category = item.category || 'General';
                    if (!groups[category]) groups[category] = [];
                    groups[category].push(item);
                    return groups;
                }, {});
                
                container.innerHTML = Object.entries(groupedItems).map(([category, items]) => `
                    <div class="knowledge-section">
                        <h3>${category}</h3>
                        ${items.map(item => this.renderKnowledgeItem(item)).join('')}
                    </div>
                `).join('');
                
                this.attachItemEventListeners();
            }
            
            renderKnowledgeItem(item) {
                const isEditing = this.currentInlineEditItem && this.currentInlineEditItem.id === item.id;
                
                if (isEditing) {
                    return this.renderInlineEditForm(item);
                }
                
                return `
                    <div class="knowledge-item" data-knowledge-id="${item.id}">
                        <div class="item-actions">
                            <button class="item-action-btn edit-btn" title="Edit Item" onclick="knowledgeModal.startInlineEditing(${item.id})">
                                <svg width="12" height="12" fill="currentColor" viewBox="0 0 16 16">
                                    <path d="M12.146.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1 0 .708L4.707 15.001H1v-3.707L12.146.146zM11.207 1.207L13.707 3.707 14.5 3l-2.5-2.5L11.207 1.207z"/>
                                </svg>
                            </button>
                            <button class="item-action-btn delete-btn" title="Delete Item" onclick="knowledgeModal.deleteKnowledgeItem(${item.id})">
                                <svg width="12" height="12" fill="currentColor" viewBox="0 0 16 16">
                                    <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/>
                                    <path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4L4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/>
                                </svg>
                            </button>
                        </div>
                        <div class="knowledge-item-title">${item.title}</div>
                        <div class="knowledge-item-description">${item.content}</div>
                        <div class="knowledge-item-tags">
                            ${(item.tags || []).map(tag => `<span class="knowledge-tag">${tag}</span>`).join('')}
                        </div>
                        <div class="knowledge-logs-section">
                            <button class="logs-toggle-btn" onclick="knowledgeModal.toggleKnowledgeLogs(${item.id})">
                                <svg width="14" height="14" fill="currentColor" viewBox="0 0 16 16">
                                    <path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
                                </svg>
                                Activity Logs
                            </button>
                            <div class="knowledge-logs-container" id="logs-${item.id}">
                                <div class="logs-loading">Loading logs...</div>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            attachItemEventListeners() {
                // Item hover effects and interactions are handled by CSS and inline onclick handlers
                // This could be expanded for more complex interactions
            }
            
            findKnowledgeItemById(id) {
                if (!this.knowledgeItems || !Array.isArray(this.knowledgeItems)) {
                    return null;
                }
                return this.knowledgeItems.find(item => item.id == id);
            }
            
            performSearch(searchTerm) {
                const items = this.modal.querySelectorAll('.knowledge-item');
                const sections = this.modal.querySelectorAll('.knowledge-section');
                let hasResults = false;
                
                sections.forEach(section => {
                    let sectionHasVisibleItems = false;
                    const sectionItems = section.querySelectorAll('.knowledge-item');
                    
                    sectionItems.forEach(item => {
                        const title = item.querySelector('.knowledge-item-title')?.textContent.toLowerCase() || '';
                        const description = item.querySelector('.knowledge-item-description')?.textContent.toLowerCase() || '';
                        const tags = Array.from(item.querySelectorAll('.knowledge-tag'))
                                         .map(tag => tag.textContent.toLowerCase()).join(' ');
                        
                        const isMatch = !searchTerm || 
                                       title.includes(searchTerm) || 
                                       description.includes(searchTerm) || 
                                       tags.includes(searchTerm);
                        
                        if (isMatch) {
                            item.style.display = '';
                            sectionHasVisibleItems = true;
                            hasResults = true;
                        } else {
                            item.style.display = 'none';
                        }
                    });
                    
                    const sectionHeader = section.querySelector('h3');
                    if (sectionHeader) {
                        sectionHeader.style.display = sectionHasVisibleItems ? '' : 'none';
                    }
                });
                
                this.toggleNoResultsMessage(!hasResults && searchTerm);
            }
            
            filterByCategory(category) {
                const sections = this.modal.querySelectorAll('.knowledge-section');
                
                sections.forEach(section => {
                    const sectionTitle = section.querySelector('h3')?.textContent.trim();
                    const shouldShow = !category || sectionTitle === category;
                    section.style.display = shouldShow ? '' : 'none';
                });
            }
            
            toggleNoResultsMessage(show) {
                let noResultsMsg = this.modal.querySelector('.no-results-message');
                
                if (show && !noResultsMsg) {
                    noResultsMsg = document.createElement('div');
                    noResultsMsg.className = 'no-results-message';
                    noResultsMsg.style.cssText = `
                        text-align: center; 
                        color: #6b7280; 
                        padding: 2rem; 
                        font-style: italic;
                    `;
                    noResultsMsg.textContent = 'No knowledge items match your search.';
                    document.getElementById('knowledgeItemsContainer').appendChild(noResultsMsg);
                } else if (!show && noResultsMsg) {
                    noResultsMsg.remove();
                }
            }
            
            renderEmptyState() {
                const container = document.getElementById('knowledgeItemsContainer');
                container.innerHTML = `
                    <div class="knowledge-section">
                        <h3>No Knowledge Items</h3>
                        <div class="knowledge-item">
                            <div class="knowledge-item-title">No knowledge has been added yet</div>
                            <div class="knowledge-item-description">
                                Click the "Add New" button above to create your first knowledge item.
                            </div>
                        </div>
                    </div>
                `;
            }
            
            renderErrorState() {
                const container = document.getElementById('knowledgeItemsContainer');
                container.innerHTML = `
                    <div class="knowledge-section">
                        <h3>Error Loading Knowledge</h3>
                        <div class="knowledge-item">
                            <div class="knowledge-item-title">Failed to load knowledge items</div>
                            <div class="knowledge-item-description">
                                There was an error loading knowledge from the server. Please try again later.
                            </div>
                        </div>
                    </div>
                `;
            }
            
            // Utility method for timestamp formatting
            formatTimestamp(timestamp) {
                if (!timestamp) return 'N/A';
                
                try {
                    // Handle various timestamp formats
                    let cleanTimestamp = timestamp;
                    if (typeof timestamp === 'string') {
                        // Handle format like "2025-09-09T22:17:18.852152+00:00Z" - remove Z after timezone
                        cleanTimestamp = timestamp.replace(/\+00:00Z$/, '+00:00');
                        // Handle format ending with just 'Z'
                        cleanTimestamp = cleanTimestamp.replace(/Z$/, '');
                        // Handle microseconds - truncate to milliseconds for better browser compatibility
                        cleanTimestamp = cleanTimestamp.replace(/\.\d{6}/, function(match) {
                            return match.substring(0, 4); // Keep only 3 digits after decimal
                        });
                    }
                    
                    const date = new Date(cleanTimestamp);
                    
                    // Validate the date is actually valid
                    if (isNaN(date.getTime())) {
                        console.warn('Invalid timestamp format:', timestamp, 'cleaned to:', cleanTimestamp);
                        return 'Invalid Date';
                    }
                    
                    // Format as local date/time
                    return date.toLocaleString('en-US', {
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit',
                        hour12: false
                    });
                } catch (error) {
                    console.error('Error formatting timestamp:', error, 'for timestamp:', timestamp);
                    return 'Format Error';
                }
            }
        }

        class AssumptionInsightsModal {
            constructor() {
                this.modal = document.getElementById('assumption-insights-modal');
                this.drawer = document.getElementById('assumption-detail-drawer');
                this.isLoading = false;
                this.cache = {
                    projects: null,
                    epics: null,
                    lastRefresh: null
                };
                this.filters = {
                    project_id: '',
                    epic_id: '',
                    start_date: '',
                    end_date: ''
                };
                
                this.initializeEventListeners();
            }
            
            initializeEventListeners() {
                // Close button and backdrop click
                const closeBtn = document.getElementById('assumptionModalCloseBtn');
                if (closeBtn) {
                    closeBtn.addEventListener('click', () => this.close());
                }
                
                // Backdrop click closes modal
                this.modal.addEventListener('click', (e) => {
                    if (e.target === this.modal) {
                        this.close();
                    }
                });
                
                // Escape key closes modal
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && this.modal.style.display !== 'none') {
                        this.close();
                    }
                });
                
                // Filter change handlers
                const projectSelect = document.getElementById('assumption-project-select');
                if (projectSelect) {
                    projectSelect.addEventListener('change', (e) => {
                        this.filters.project_id = e.target.value;
                        this.updateEpicOptions();
                        this.debouncedLoadData();
                    });
                }
                
                const epicSelect = document.getElementById('assumption-epic-select');
                if (epicSelect) {
                    epicSelect.addEventListener('change', (e) => {
                        this.filters.epic_id = e.target.value;
                        this.debouncedLoadData();
                    });
                }
                
                const startDateInput = document.getElementById('assumption-start-date');
                if (startDateInput) {
                    startDateInput.addEventListener('change', (e) => {
                        this.filters.start_date = e.target.value;
                        this.debouncedLoadData();
                    });
                }
                
                const endDateInput = document.getElementById('assumption-end-date');
                if (endDateInput) {
                    endDateInput.addEventListener('change', (e) => {
                        this.filters.end_date = e.target.value;
                        this.debouncedLoadData();
                    });
                }
                
                // Drawer close button
                const drawerCloseBtn = document.getElementById('drawerCloseBtn');
                if (drawerCloseBtn) {
                    drawerCloseBtn.addEventListener('click', () => this.closeDrawer());
                }
            }
            
            // Debounced data loading to prevent excessive API calls
            debouncedLoadData() {
                clearTimeout(this.loadDataTimeout);
                this.loadDataTimeout = setTimeout(() => {
                    this.loadInsightsData();
                }, 300);
            }
            
            async open() {
                if (this.isLoading) return;
                
                this.modal.style.display = 'flex';
                
                // Show global loading state
                this.showGlobalLoading();
                
                try {
                    // Load filter options first (cached for performance)
                    await this.loadFilterOptions();
                    
                    // Load insights data
                    await this.loadInsightsData();
                    
                    this.hideGlobalLoading();
                } catch (error) {
                    console.error('Error opening assumption insights modal:', error);
                    this.showError('Failed to load assumption insights. Please try again.');
                    this.hideGlobalLoading();
                }
            }
            
            close() {
                this.modal.style.display = 'none';
                this.closeDrawer();
            }
            
            async loadFilterOptions() {
                try {
                    // Use cache if available and recent (5 minutes)
                    const now = Date.now();
                    if (this.cache.projects && this.cache.lastRefresh && 
                        (now - this.cache.lastRefresh) < 5 * 60 * 1000) {
                        this.populateFilterOptions();
                        return;
                    }
                    
                    // Load projects and epics
                    const [projectsResponse, epicsResponse] = await Promise.all([
                        fetch('/api/projects'),
                        fetch('/api/epics')
                    ]);
                    
                    if (!projectsResponse.ok) throw new Error(`Projects API error: ${projectsResponse.status}`);
                    if (!epicsResponse.ok) throw new Error(`Epics API error: ${epicsResponse.status}`);
                    
                    const [projects, epics] = await Promise.all([
                        projectsResponse.json(),
                        epicsResponse.json()
                    ]);
                    
                    this.cache.projects = projects;
                    this.cache.epics = epics;
                    this.cache.lastRefresh = now;
                    
                    this.populateFilterOptions();
                } catch (error) {
                    console.error('Error loading filter options:', error);
                    this.showError('Failed to load filter options.');
                }
            }
            
            populateFilterOptions() {
                const projectSelect = document.getElementById('assumption-project-select');
                const epicSelect = document.getElementById('assumption-epic-select');
                
                if (projectSelect && this.cache.projects) {
                    projectSelect.innerHTML = '<option value="">All Projects</option>';
                    this.cache.projects.forEach(project => {
                        const option = document.createElement('option');
                        option.value = project.id;
                        option.textContent = project.name;
                        if (this.filters.project_id == project.id) option.selected = true;
                        projectSelect.appendChild(option);
                    });
                }
                
                this.updateEpicOptions();
            }
            
            updateEpicOptions() {
                const epicSelect = document.getElementById('assumption-epic-select');
                if (!epicSelect || !this.cache.epics) return;
                
                epicSelect.innerHTML = '<option value="">All Epics</option>';
                
                // Filter epics by selected project
                let epicsToShow = this.cache.epics;
                if (this.filters.project_id) {
                    epicsToShow = this.cache.epics.filter(epic => epic.project_id == this.filters.project_id);
                }
                
                epicsToShow.forEach(epic => {
                    const option = document.createElement('option');
                    option.value = epic.id;
                    option.textContent = epic.name;
                    if (this.filters.epic_id == epic.id) option.selected = true;
                    epicSelect.appendChild(option);
                });
                
                // Reset epic filter if current selection is not valid for project
                if (this.filters.project_id && this.filters.epic_id) {
                    const validEpic = epicsToShow.find(epic => epic.id == this.filters.epic_id);
                    if (!validEpic) {
                        this.filters.epic_id = '';
                        epicSelect.value = '';
                    }
                }
            }
            
            async loadInsightsData() {
                if (this.isLoading) return;
                
                this.isLoading = true;
                this.showLoadingStates();
                
                try {
                    // Build query parameters
                    const params = new URLSearchParams();
                    if (this.filters.project_id) params.append('project_id', this.filters.project_id);
                    if (this.filters.epic_id) params.append('epic_id', this.filters.epic_id);
                    if (this.filters.start_date) params.append('start_date', this.filters.start_date);
                    if (this.filters.end_date) params.append('end_date', this.filters.end_date);
                    
                    // Load all data in parallel
                    const [insightsResponse, recentResponse] = await Promise.all([
                        fetch(`/api/assumptions/insights?${params.toString()}`),
                        fetch(`/api/assumptions/recent?${params.toString()}`)
                    ]);
                    
                    if (!insightsResponse.ok) throw new Error(`Insights API error: ${insightsResponse.status}`);
                    if (!recentResponse.ok) throw new Error(`Recent validations API error: ${recentResponse.status}`);
                    
                    const [insights, recent] = await Promise.all([
                        insightsResponse.json(),
                        recentResponse.json()
                    ]);
                    
                    // Update UI with loaded data
                    this.updateKPICards(insights);
                    this.updateTopRisksTable(insights.tag_type_breakdown || {}, insights.recent_examples || []);
                    this.updateRecentValidationsTable(recent.validations || []);
                    
                    this.hideLoadingStates();
                } catch (error) {
                    console.error('Error loading insights data:', error);
                    this.showError('Failed to load insights data. Please try again.');
                    this.hideLoadingStates();
                } finally {
                    this.isLoading = false;
                }
            }
            
            updateKPICards(insights) {
                // Extract data from outcome_breakdown
                const outcomeBreakdown = insights.outcome_breakdown || {};
                const totalValidations = insights.total_validations || 0;
                const successfulValidations = outcomeBreakdown.validated || 0;
                const partialValidations = outcomeBreakdown.partial || 0;
                const rejectedValidations = outcomeBreakdown.rejected || 0;
                
                // Use the success_rate from API (already calculated with partial weighting)
                const successRate = (insights.success_rate || 0) * 100;
                
                // Update KPI values
                document.getElementById('success-rate-value').textContent = totalValidations > 0 ? `${successRate.toFixed(1)}%` : '--';
                document.getElementById('success-rate-subtitle').textContent = totalValidations > 0 
                    ? `${successfulValidations} successful, ${partialValidations} partial` 
                    : 'No data available';
                
                document.getElementById('total-validations-value').textContent = totalValidations.toLocaleString();
                document.getElementById('total-validations-subtitle').textContent = totalValidations > 0
                    ? `${rejectedValidations} failed validations`
                    : 'No validations recorded';
                
                document.getElementById('partial-validations-value').textContent = partialValidations.toLocaleString();
                document.getElementById('partial-validations-subtitle').textContent = partialValidations > 0
                    ? `${((partialValidations / totalValidations) * 100).toFixed(1)}% of total`
                    : 'No partial validations';
            }
            
            updateTopRisksTable(tagTypeBreakdown, recentExamples) {
                const tbody = document.getElementById('top-risks-tbody');
                const emptyState = document.getElementById('top-risks-empty');
                const table = document.getElementById('top-risks-table');
                
                // Convert tag_type_breakdown object to array and get detailed stats from recent examples
                const tagTypes = Object.entries(tagTypeBreakdown).map(([tagType, count]) => {
                    // Calculate stats for this tag type from recent examples
                    const tagExamples = recentExamples.filter(ex => ex.ra_tag === tagType);
                    const validated = tagExamples.filter(ex => ex.outcome === 'validated').length;
                    const rejected = tagExamples.filter(ex => ex.outcome === 'rejected').length;
                    const partial = tagExamples.filter(ex => ex.outcome === 'partial').length;
                    const total = validated + rejected + partial;
                    
                    // Calculate success rate (partial = 0.5 weight)
                    const successRate = total > 0 ? (validated + (partial * 0.5)) / total : 0;
                    
                    // Get most recent timestamp
                    const lastSeen = tagExamples.length > 0 
                        ? Math.max(...tagExamples.map(ex => new Date(ex.validated_at).getTime()))
                        : Date.now();
                    
                    return {
                        tag_type: tagType,
                        success_rate: successRate,
                        total_count: total,
                        validated_count: validated,
                        rejected_count: rejected,
                        partial_count: partial,
                        last_seen: lastSeen
                    };
                });
                
                if (tagTypes.length === 0) {
                    table.style.display = 'none';
                    emptyState.style.display = 'block';
                    return;
                }
                
                table.style.display = 'table';
                emptyState.style.display = 'none';
                
                // Sort by success rate (ascending - lowest first are highest risk)
                tagTypes.sort((a, b) => a.success_rate - b.success_rate);
                
                tbody.innerHTML = tagTypes.map(tag => {
                    const successRate = tag.success_rate * 100;
                    const validations = tag.validated_count;
                    const rejected = tag.rejected_count;
                    const partial = tag.partial_count;
                    const lastSeen = this.formatDate(new Date(tag.last_seen));
                    
                    const riskClass = successRate < 50 ? 'high-risk' : successRate < 75 ? 'medium-risk' : 'low-risk';
                    
                    return `
                        <tr class="table-row clickable" data-tag-type="${tag.tag_type}" onclick="assumptionInsightsModal.openTagDetails('${tag.tag_type}')">
                            <td class="tag-type-cell">
                                <span class="tag-pill">${tag.tag_type}</span>
                            </td>
                            <td>
                                <div class="success-rate-cell">
                                    <span class="success-rate-value ${riskClass}">${successRate.toFixed(1)}%</span>
                                    <div class="success-rate-bar">
                                        <div class="success-rate-fill ${riskClass}" style="width: ${successRate}%"></div>
                                    </div>
                                </div>
                            </td>
                            <td class="validations-cell">
                                <span class="validation-counts">${validations}/${rejected}/${partial}</span>
                            </td>
                            <td class="last-seen-cell">${lastSeen}</td>
                        </tr>
                    `;
                }).join('');
            }
            
            updateRecentValidationsTable(validations) {
                const tbody = document.getElementById('recent-validations-tbody');
                const emptyState = document.getElementById('recent-validations-empty');
                const table = document.getElementById('recent-validations-table');
                
                if (validations.length === 0) {
                    table.style.display = 'none';
                    emptyState.style.display = 'block';
                    return;
                }
                
                table.style.display = 'table';
                emptyState.style.display = 'none';
                
                tbody.innerHTML = validations.map(validation => {
                    const timestamp = this.formatTimestamp(validation.validated_at);
                    const outcome = validation.outcome || 'unknown';
                    const reason = validation.notes || 'No reason provided';
                    const truncatedReason = reason.length > 50 ? reason.substring(0, 50) + '...' : reason;
                    
                    const outcomeClass = (outcome === 'validated' || outcome === 'successful') ? 'success' : 
                                       outcome === 'partial' ? 'warning' : 'danger';
                    
                    return `
                        <tr class="table-row">
                            <td class="timestamp-cell">${timestamp}</td>
                            <td class="tag-type-cell">
                                <span class="tag-pill">${validation.ra_tag || validation.ra_tag_type}</span>
                            </td>
                            <td>
                                <span class="outcome-badge ${outcomeClass}">${outcome}</span>
                            </td>
                            <td class="reason-cell" title="${reason}">${truncatedReason}</td>
                            <td class="task-cell">
                                ${validation.task_name ? `<a href="#" onclick="openTaskDetailModal({id: ${validation.task_id}, name: '${validation.task_name.replace(/'/g, "\\'")}'}); return false;" class="task-link">${validation.task_name}</a>` : 'N/A'}
                            </td>
                        </tr>
                    `;
                }).join('');
            }
            
            async openTagDetails(tagType) {
                try {
                    this.showDrawerLoading();
                    this.openDrawer(tagType);
                    
                    // Load tag-specific data
                    const params = new URLSearchParams();
                    params.append('tag_type', tagType);
                    if (this.filters.project_id) params.append('project_id', this.filters.project_id);
                    if (this.filters.epic_id) params.append('epic_id', this.filters.epic_id);
                    if (this.filters.start_date) params.append('start_date', this.filters.start_date);
                    if (this.filters.end_date) params.append('end_date', this.filters.end_date);
                    
                    const response = await fetch(`/api/assumptions/tag-details?${params.toString()}`);
                    if (!response.ok) throw new Error(`Tag details API error: ${response.status}`);
                    
                    const data = await response.json();
                    this.updateDrawerContent(tagType, data);
                    this.hideDrawerLoading();
                } catch (error) {
                    console.error('Error loading tag details:', error);
                    this.showDrawerError('Failed to load tag details.');
                    this.hideDrawerLoading();
                }
            }
            
            openDrawer(tagType) {
                const title = document.getElementById('drawer-tag-title');
                const subtitle = document.getElementById('drawer-tag-subtitle');
                
                if (title) title.textContent = tagType;
                if (subtitle) subtitle.textContent = 'Loading validation data...';
                
                this.drawer.classList.add('open');
            }
            
            closeDrawer() {
                this.drawer.classList.remove('open');
            }
            
            updateDrawerContent(tagType, data) {
                const subtitle = document.getElementById('drawer-tag-subtitle');
                const metricsContent = document.getElementById('drawer-metrics-content');
                const historyContent = document.getElementById('drawer-history-content');
                const reasonsContent = document.getElementById('drawer-reasons-content');
                
                if (subtitle) {
                    subtitle.textContent = `${data.total_validations || 0} total validations`;
                }
                
                // Update metrics
                if (metricsContent) {
                    const successRate = (data.success_rate || 0) * 100;
                    metricsContent.innerHTML = `
                        <div class="metric-item">
                            <span class="metric-label">Success Rate:</span>
                            <span class="metric-value ${successRate < 50 ? 'danger' : successRate < 75 ? 'warning' : 'success'}">
                                ${successRate.toFixed(1)}%
                            </span>
                        </div>
                        <div class="metric-item">
                            <span class="metric-label">Successful:</span>
                            <span class="metric-value">${data.successful_count || 0}</span>
                        </div>
                        <div class="metric-item">
                            <span class="metric-label">Partial:</span>
                            <span class="metric-value">${data.partial_count || 0}</span>
                        </div>
                        <div class="metric-item">
                            <span class="metric-label">Failed:</span>
                            <span class="metric-value">${data.rejected_count || 0}</span>
                        </div>
                    `;
                }
                
                // Update validation history
                if (historyContent) {
                    const validations = data.recent_validations || [];
                    if (validations.length === 0) {
                        historyContent.innerHTML = '<p class="no-data">No validation history available.</p>';
                    } else {
                        historyContent.innerHTML = validations.map(v => `
                            <div class="history-item">
                                <div class="history-header">
                                    <span class="outcome-badge ${(v.outcome === 'successful' || v.outcome === 'validated') ? 'success' : v.outcome === 'partial' ? 'warning' : 'danger'}">
                                        ${v.outcome === 'validated' ? 'successful' : v.outcome}
                                    </span>
                                    <span class="history-timestamp">${this.formatTimestamp(v.validated_at)}</span>
                                </div>
                                <div class="history-content">
                                    <p class="history-reason">${v.notes || 'No reason provided'}</p>
                                    ${v.task_name ? `<p class="history-task">Task: ${v.task_name}</p>` : ''}
                                </div>
                            </div>
                        `).join('');
                    }
                }
                
                // Update common reasons
                if (reasonsContent) {
                    const reasons = data.common_reasons || [];
                    if (reasons.length === 0) {
                        reasonsContent.innerHTML = '<p class="no-data">No common reasons identified.</p>';
                    } else {
                        reasonsContent.innerHTML = reasons.map(reason => `
                            <div class="reason-item">
                                <div class="reason-text">${reason.reason}</div>
                                <div class="reason-meta">
                                    <span class="reason-count">${reason.count} times</span>
                                    <span class="reason-outcome ${reason.primary_outcome === 'successful' ? 'success' : reason.primary_outcome === 'partial' ? 'warning' : 'danger'}">
                                        Usually: ${reason.primary_outcome}
                                    </span>
                                </div>
                            </div>
                        `).join('');
                    }
                }
            }
            
            showGlobalLoading() {
                const globalLoading = document.getElementById('assumption-global-loading');
                if (globalLoading) globalLoading.style.display = 'flex';
            }
            
            hideGlobalLoading() {
                const globalLoading = document.getElementById('assumption-global-loading');
                if (globalLoading) globalLoading.style.display = 'none';
            }
            
            showLoadingStates() {
                const topRisksLoading = document.getElementById('top-risks-loading');
                const recentValidationsLoading = document.getElementById('recent-validations-loading');
                
                if (topRisksLoading) topRisksLoading.style.display = 'flex';
                if (recentValidationsLoading) recentValidationsLoading.style.display = 'flex';
            }
            
            hideLoadingStates() {
                const topRisksLoading = document.getElementById('top-risks-loading');
                const recentValidationsLoading = document.getElementById('recent-validations-loading');
                
                if (topRisksLoading) topRisksLoading.style.display = 'none';
                if (recentValidationsLoading) recentValidationsLoading.style.display = 'none';
            }
            
            showDrawerLoading() {
                const metricsContent = document.getElementById('drawer-metrics-content');
                const historyContent = document.getElementById('drawer-history-content');
                const reasonsContent = document.getElementById('drawer-reasons-content');
                
                const loadingHTML = '<div class="drawer-loading"><div class="spinner"></div><span>Loading...</span></div>';
                
                if (metricsContent) metricsContent.innerHTML = loadingHTML;
                if (historyContent) historyContent.innerHTML = loadingHTML;
                if (reasonsContent) reasonsContent.innerHTML = loadingHTML;
            }
            
            hideDrawerLoading() {
                // Content is replaced by updateDrawerContent, no explicit hide needed
            }
            
            showDrawerError(message) {
                const metricsContent = document.getElementById('drawer-metrics-content');
                const historyContent = document.getElementById('drawer-history-content');
                const reasonsContent = document.getElementById('drawer-reasons-content');
                
                const errorHTML = `<div class="error-state"><span class="error-message">${message}</span></div>`;
                
                if (metricsContent) metricsContent.innerHTML = errorHTML;
                if (historyContent) historyContent.innerHTML = errorHTML;
                if (reasonsContent) reasonsContent.innerHTML = errorHTML;
            }
            
            showError(message) {
                // Show error in a toast notification
                this.showNotification(message, 'error');
            }
            
            showNotification(message, type = 'info') {
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.textContent = message;
                
                document.body.appendChild(notification);
                
                // Auto-remove after 5 seconds
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 5000);
            }
            
            formatDate(dateString) {
                if (!dateString) return 'Never';
                
                const date = new Date(dateString);
                const now = new Date();
                const diffTime = Math.abs(now - date);
                const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
                
                if (diffDays === 0) return 'Today';
                if (diffDays === 1) return 'Yesterday';
                if (diffDays < 7) return `${diffDays} days ago`;
                if (diffDays < 30) return `${Math.floor(diffDays / 7)} weeks ago`;
                if (diffDays < 365) return `${Math.floor(diffDays / 30)} months ago`;
                
                return date.toLocaleDateString();
            }
            
            formatTimestamp(timestampString) {
                if (!timestampString) return 'Unknown';
                
                const date = new Date(timestampString);
                const now = new Date();
                const diffTime = Math.abs(now - date);
                const diffMinutes = Math.floor(diffTime / (1000 * 60));
                
                if (diffMinutes < 1) return 'Just now';
                if (diffMinutes < 60) return `${diffMinutes}m ago`;
                if (diffMinutes < 1440) return `${Math.floor(diffMinutes / 60)}h ago`;
                
                return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            }
        }

        // Initialize modal instance
        let taskDetailModal = null;
        let knowledgeModal = null;
        let assumptionInsightsModal = null;
        
        function openTaskDetailModal(task) {
            if (!taskDetailModal) {
                taskDetailModal = new TaskDetailModal();
            }
            taskDetailModal.open(task);
        }
        
        async function openKnowledgeModal() {
            if (!knowledgeModal) {
                knowledgeModal = new KnowledgeManagementModal();
            }
            await knowledgeModal.open();
        }
        
        async function openAssumptionInsightsModal() {
            if (!assumptionInsightsModal) {
                assumptionInsightsModal = new AssumptionInsightsModal();
            }
            await assumptionInsightsModal.open();
        }
        
        function updateTaskCounts() {
            const counts = {
                todo: 0,
                in_progress: 0, 
                review: 0,
                done: 0
            };
            
            const filteredTasks = getFilteredTasks();
            filteredTasks.forEach(task => {
                // Ensure we handle both database and UI status formats
                const taskStatus = task.status ? task.status.toLowerCase().trim() : 'pending';
                const statusKey = mapDatabaseStatusToUI(taskStatus);
                
                // Handle backlog/TODO view mode for counting
                if (statusKey === 'backlog') {
                    if (AppState.todoViewMode === 'BACKLOG') {
                        // In backlog view, count backlog tasks as TODO
                        counts.todo++;
                    }
                    // In TODO view, don't count backlog tasks
                } else if (statusKey === 'todo') {
                    if (AppState.todoViewMode === 'TODO') {
                        // In TODO view, count pending tasks as TODO
                        counts.todo++;
                    }
                    // In backlog view, don't count pending tasks
                } else if (counts.hasOwnProperty(statusKey)) {
                    counts[statusKey]++;
                }
            });
            
            Object.keys(counts).forEach(status => {
                const countElement = document.getElementById(`${status}-count`);
                if (countElement) {
                    const count = counts[status];
                    countElement.textContent = `${count} task${count !== 1 ? 's' : ''}`;
                }
            });
        }
        
        // #COMPLETION_DRIVE_DRAGDROP: Drag and drop implementation with cross-browser support
        // Pattern: HTML5 Drag API with fallback handling for touch devices
        function initializeDragAndDrop() {
            let draggedTask = null;
            
            // #COMPLETION_DRIVE_DRAGDROP: Enhanced drag support with improved event handling
            // Pattern: Coordinate drag operations with click handlers for optimal UX
            document.addEventListener('dragstart', function(e) {
                if (e.target.classList.contains('task-card')) {
                    // Don't allow dragging locked tasks
                    if (e.target.classList.contains('locked')) {
                        e.preventDefault();
                        showNotification('Cannot move locked task', 'error');
                        return;
                    }
                    
                    draggedTask = e.target;
                    e.target.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/html', e.target.outerHTML);
                    e.dataTransfer.setData('text/plain', e.target.dataset.taskId);
                    
                    // Prevent click events during drag
                    setTimeout(() => {
                        if (draggedTask) {
                            draggedTask.style.pointerEvents = 'none';
                        }
                    }, 0);
                }
            });
            
            document.addEventListener('dragend', function(e) {
                if (e.target.classList.contains('task-card')) {
                    e.target.classList.remove('dragging');
                    // Restore click functionality after drag
                    e.target.style.pointerEvents = 'auto';
                    draggedTask = null;
                }
            });
            
            document.addEventListener('dragover', function(e) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                
                const taskContainer = e.target.closest('.tasks');
                if (taskContainer) {
                    taskContainer.classList.add('drag-over');
                }
            });
            
            document.addEventListener('dragleave', function(e) {
                const taskContainer = e.target.closest('.tasks');
                if (taskContainer && !taskContainer.contains(e.relatedTarget)) {
                    taskContainer.classList.remove('drag-over');
                }
            });
            
            document.addEventListener('drop', function(e) {
                e.preventDefault();
                
                const taskContainer = e.target.closest('.tasks');
                if (taskContainer) {
                    taskContainer.classList.remove('drag-over');
                    
                    const taskId = e.dataTransfer.getData('text/plain');
                    const column = taskContainer.closest('.column');
                    const newStatus = column.dataset.status;
                    
                    if (draggedTask && taskId) {
                        updateTaskStatusOptimistic(taskId, newStatus);
                    }
                }
            });
        }
        
        // #COMPLETION_DRIVE_OPTIMISTIC: Optimistic updates with rollback capability
        // Pattern: Immediate UI feedback with server synchronization and error recovery
        async function updateTaskStatusOptimistic(taskId, newStatus) {
            console.log(`Looking for task: ID=${taskId} (type: ${typeof taskId}), converted to string: "${String(taskId)}"`);
            console.log('Available task IDs:', Array.from(AppState.tasks.keys()));
            const task = AppState.tasks.get(String(taskId));
            if (!task) {
                console.error('Task not found:', taskId);
                return;
            }
            
            // Store original state for rollback
            const originalStatus = task.status;
            AppState.pendingUpdates.set(String(taskId), { status: originalStatus });
            
            // Remove task from its current position first
            const existingElement = document.getElementById(`task-${task.id}`);
            if (existingElement) {
                existingElement.remove();
            }
            
            // Apply optimistic update
            task.status = newStatus;
            AppState.tasks.set(String(taskId), task);
            renderTask(task);
            updateTaskCounts();
            
            try {
                console.log(`Updating task ${taskId} status to ${newStatus}`);
                
                const response = await fetch(`/api/task/${taskId}/status`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        status: newStatus,
                        agent_id: 'dashboard-user'
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.detail || `HTTP ${response.status}`);
                }
                
                const result = await response.json();
                console.log('Task status updated successfully:', result);
                
                // Clear pending update on success
                AppState.pendingUpdates.delete(String(taskId));
                showNotification(`Task moved to ${newStatus}`, 'success');
                
            } catch (error) {
                console.error('Failed to update task status:', error);
                
                // Rollback optimistic update
                const originalState = AppState.pendingUpdates.get(String(taskId));
                if (originalState) {
                    task.status = originalState.status;
                    AppState.tasks.set(String(taskId), task);
                    renderTask(task);
                    updateTaskCounts();
                }
                
                AppState.pendingUpdates.delete(String(taskId));
                showNotification(`Failed to update task: ${error.message}`, 'error');
            }
        }
        
        // #COMPLETION_DRIVE_UX: User notification system for feedback
        // Pattern: Non-intrusive notifications for user actions and system events
        function showNotification(message, type = 'info', duration = 3000) {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            // Trigger show animation
            setTimeout(() => notification.classList.add('show'), 10);
            
            // Auto-hide notification
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, duration);
        }
        
        // Utility function for XSS prevention
        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, function(m) { return map[m]; });
        }

        // Delete functionality
        let deleteData = null; // Stores what to delete (project/epic info)

        function updateDeleteButtonVisibility() {
            const deleteBtn = document.getElementById('deleteFilterButton');
            const projectSelector = document.getElementById('projectSelector');
            const epicSelector = document.getElementById('epicSelector');
            
            if (!deleteBtn || !projectSelector || !epicSelector) return;
            
            // Show delete button if either a project or epic is selected
            const showButton = projectSelector.value || epicSelector.value;
            deleteBtn.style.display = showButton ? 'block' : 'none';
        }

        function showDeleteModal() {
            const projectSelector = document.getElementById('projectSelector');
            const epicSelector = document.getElementById('epicSelector');
            const modal = document.getElementById('deleteModal');
            const messageEl = document.getElementById('deleteModalMessage');
            
            if (!projectSelector || !epicSelector || !modal || !messageEl) return;
            
            deleteData = null;
            
            // Determine what to delete based on selections
            if (epicSelector.value) {
                // Epic is selected - delete epic
                const epicName = epicSelector.options[epicSelector.selectedIndex].text;
                const projectName = projectSelector.options[projectSelector.selectedIndex].text;
                deleteData = {
                    type: 'epic',
                    id: parseInt(epicSelector.value),
                    name: epicName,
                    projectName: projectName
                };
                messageEl.textContent = `Are you sure you want to delete the epic "${epicName}"?`;
            } else if (projectSelector.value) {
                // Only project is selected - delete project
                const projectName = projectSelector.options[projectSelector.selectedIndex].text;
                deleteData = {
                    type: 'project',
                    id: parseInt(projectSelector.value),
                    name: projectName
                };
                messageEl.textContent = `Are you sure you want to delete the project "${projectName}"?`;
            } else {
                return; // Nothing selected
            }
            
            modal.style.display = 'flex';
        }

        function closeDeleteModal() {
            const modal = document.getElementById('deleteModal');
            if (modal) {
                modal.style.display = 'none';
            }
            deleteData = null;
        }

        async function confirmDelete() {
            if (!deleteData) {
                closeDeleteModal();
                return;
            }
            
            const confirmBtn = document.getElementById('confirmDeleteBtn');
            if (confirmBtn) {
                confirmBtn.disabled = true;
                confirmBtn.textContent = 'Deleting...';
            }
            
            try {
                let response;
                if (deleteData.type === 'project') {
                    response = await fetch(`/api/projects/${deleteData.id}`, {
                        method: 'DELETE',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                } else if (deleteData.type === 'epic') {
                    response = await fetch(`/api/epics/${deleteData.id}`, {
                        method: 'DELETE',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                } else if (deleteData.type === 'task') {
                    response = await fetch(`/api/tasks/${deleteData.id}`, {
                        method: 'DELETE',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                }
                
                if (response && response.ok) {
                    const result = await response.json();
                    console.log('Deletion successful:', result);
                    
                    // Reset UI state before closing modal
                    if (deleteData.type === 'project') {
                        AppState.selectedProjectId = null;
                        AppState.selectedEpicId = null;
                    } else if (deleteData.type === 'epic') {
                        AppState.selectedEpicId = null;
                    } else if (deleteData.type === 'task') {
                        // Remove task from local state and UI
                        AppState.tasks.delete(String(deleteData.id));
                        const taskElement = document.getElementById(`task-${deleteData.id}`);
                        if (taskElement) {
                            taskElement.remove();
                        }
                        // Update task counts
                        updateTaskCounts();
                    }
                    
                    // Close modal and reset selections
                    closeDeleteModal();
                    
                    saveSelectionState();
                    updateDeleteButtonVisibility();
                    
                    // Refresh data will be handled by WebSocket events
                } else {
                    const errorData = await response.json().catch(() => ({}));
                    console.error('Delete failed:', errorData);
                    alert(`Failed to delete ${deleteData.type}: ${errorData.error || 'Unknown error'}`);
                }
            } catch (error) {
                console.error('Delete error:', error);
                alert(`Failed to delete ${deleteData.type}: ${error.message}`);
            } finally {
                if (confirmBtn) {
                    confirmBtn.disabled = false;
                    confirmBtn.textContent = 'Delete';
                }
            }
        }

        // Add event listeners for delete functionality
        function setupDeleteHandlers() {
            const deleteBtn = document.getElementById('deleteFilterButton');
            const projectSelector = document.getElementById('projectSelector');
            const epicSelector = document.getElementById('epicSelector');
            const modal = document.getElementById('deleteModal');
            
            if (deleteBtn) {
                deleteBtn.addEventListener('click', showDeleteModal);
            }
            
            if (projectSelector) {
                projectSelector.addEventListener('change', updateDeleteButtonVisibility);
            }
            
            if (epicSelector) {
                epicSelector.addEventListener('change', updateDeleteButtonVisibility);
            }
            
            // Close modal when clicking outside
            if (modal) {
                modal.addEventListener('click', function(e) {
                    if (e.target === modal) {
                        closeDeleteModal();
                    }
                });
            }
            
            // Close modal with Escape key
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && modal && modal.style.display === 'flex') {
                    closeDeleteModal();
                }
            });
        }

        // #COMPLETION_DRIVE_SETUP: Knowledge Management button event handler setup
        // RA-Light Mode: Comprehensive event binding with error handling
        function setupKnowledgeHandlers() {
            const knowledgeBtn = document.getElementById('knowledgeBtn');
            
            if (knowledgeBtn) {
                knowledgeBtn.addEventListener('click', async (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    try {
                        await openKnowledgeModal();
                    } catch (error) {
                        console.error('Error opening knowledge modal:', error);
                        showNotification('Error opening Knowledge Management', 'error');
                    }
                });
                
                // Add keyboard accessibility (Enter and Space keys)
                knowledgeBtn.addEventListener('keydown', async (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        try {
                            await openKnowledgeModal();
                        } catch (error) {
                            console.error('Error opening knowledge modal via keyboard:', error);
                            showNotification('Error opening Knowledge Management', 'error');
                        }
                    }
                });
                
                console.log('Knowledge Management button handlers initialized');
            } else {
                console.warn('Knowledge button not found during initialization');
            }
        }

        // Assumption Insights button event handler setup
        function setupAssumptionInsightsHandlers() {
            const assumptionInsightsBtn = document.getElementById('assumptionInsightsBtn');
            
            if (assumptionInsightsBtn) {
                assumptionInsightsBtn.addEventListener('click', async (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    try {
                        await openAssumptionInsightsModal();
                    } catch (error) {
                        console.error('Error opening assumption insights modal:', error);
                        showNotification('Error opening Assumption Insights', 'error');
                    }
                });
                
                // Add keyboard accessibility (Enter and Space keys)
                assumptionInsightsBtn.addEventListener('keydown', async (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        try {
                            await openAssumptionInsightsModal();
                        } catch (error) {
                            console.error('Error opening assumption insights modal via keyboard:', error);
                            showNotification('Error opening Assumption Insights', 'error');
                        }
                    }
                });
                
                console.log('Assumption Insights button handlers initialized');
            } else {
                console.warn('Assumption Insights button not found during initialization');
            }
        }
        
        // #COMPLETION_DRIVE_LIFECYCLE: Application initialization and cleanup
        // Pattern: Proper resource management and event handling setup
        function initializeApp() {
            console.log('Initializing Project Manager Dashboard');
            
            // Load initial data
            loadBoardState();
            
            // Initialize WebSocket connection
            initializeWebSocket();
            
            // Setup drag and drop
            initializeDragAndDrop();
            
            // Setup delete handlers
            setupDeleteHandlers();
            
            // Setup knowledge management handlers
            setupKnowledgeHandlers();
            
            // Setup assumption insights handlers
            setupAssumptionInsightsHandlers();
            
            // Setup filter event listeners
            const projectSelector = document.getElementById('projectSelector');
            const epicSelector = document.getElementById('epicSelector');
            
            if (projectSelector) {
                projectSelector.addEventListener('change', handleProjectChange);
            }
            
            if (epicSelector) {
                epicSelector.addEventListener('change', handleEpicChange);
            }
            
            // Setup TODO/Backlog toggle
            const toggleButton = document.getElementById('todo-backlog-toggle');
            if (toggleButton) {
                toggleButton.addEventListener('click', handleTodoBacklogToggle);
            }
            
            // Handle online/offline events
            window.addEventListener('online', function() {
                console.log('Connection restored');
                AppState.isOnline = true;
                if (!AppState.socket || AppState.socket.readyState === WebSocket.CLOSED) {
                    AppState.connectionAttempts = 0;
                    AppState.reconnectDelay = 1000;
                    initializeWebSocket();
                }
            });
            
            window.addEventListener('offline', function() {
                console.log('Connection lost');
                AppState.isOnline = false;
                updateConnectionStatus('disconnected');
            });
            
            // Handle page visibility changes for resource optimization
            document.addEventListener('visibilitychange', function() {
                if (document.hidden) {
                    // Page is hidden, reduce activity
                    console.log('Page hidden, reducing activity');
                } else {
                    // Page is visible, ensure connection
                    console.log('Page visible, ensuring connection');
                    if (!AppState.socket || AppState.socket.readyState === WebSocket.CLOSED) {
                        initializeWebSocket();
                    }
                }
            });
            
            // Handle page unload
            window.addEventListener('beforeunload', function() {
                if (AppState.socket) {
                    AppState.socket.close();
                }
                if (AppState.pollingInterval) {
                    clearInterval(AppState.pollingInterval);
                }
            });
        }
        
        // #COMPLETION_DRIVE_FILTERING: Project and Epic filtering functionality
        function populateProjectSelector() {
            const projectSelector = document.getElementById('projectSelector');
            if (!projectSelector) return;
            
            // Clear existing options except "All Projects"
            projectSelector.innerHTML = '<option value="">All Projects</option>';
            
            // Add project options sorted by name
            const projects = Array.from(AppState.projects.values())
                .sort((a, b) => a.name.localeCompare(b.name));
            
            projects.forEach(project => {
                const option = document.createElement('option');
                option.value = project.id;
                option.textContent = project.name;
                projectSelector.appendChild(option);
            });
            
            // Restore saved selection
            if (AppState.selectedProjectId) {
                projectSelector.value = AppState.selectedProjectId;
            }
            
            // Update delete button visibility
            updateDeleteButtonVisibility();
        }
        
        function populateEpicSelector() {
            const epicSelector = document.getElementById('epicSelector');
            if (!epicSelector) return;
            
            // Clear existing options except "All Epics"
            epicSelector.innerHTML = '<option value="">All Epics</option>';
            
            // Filter epics based on selected project
            let epics = Array.from(AppState.epics.values());
            if (AppState.selectedProjectId) {
                epics = epics.filter(epic => epic.project_id == AppState.selectedProjectId);
                // Change the "All Epics" text to be more specific
                epicSelector.options[0].textContent = 'All Epics in Project';
            } else {
                epicSelector.options[0].textContent = 'All Epics';
            }
            
            // Add epic options sorted by name
            epics.sort((a, b) => a.name.localeCompare(b.name))
                .forEach(epic => {
                    const option = document.createElement('option');
                    option.value = epic.id;
                    option.textContent = epic.name;
                    epicSelector.appendChild(option);
                });
            
            // Restore saved selection if still valid
            if (AppState.selectedEpicId) {
                const epicExists = epics.some(epic => epic.id == AppState.selectedEpicId);
                if (epicExists) {
                    epicSelector.value = AppState.selectedEpicId;
                } else {
                    // Clear invalid epic selection
                    AppState.selectedEpicId = null;
                    saveSelectionState();
                }
            }
            
            // Update delete button visibility
            updateDeleteButtonVisibility();
        }
        
        function handleTodoBacklogToggle() {
            // Toggle between TODO and BACKLOG view modes
            AppState.todoViewMode = AppState.todoViewMode === 'TODO' ? 'BACKLOG' : 'TODO';
            
            // Update column title
            const titleElement = document.getElementById('todo-column-title');
            if (titleElement) {
                titleElement.textContent = AppState.todoViewMode;
            }
            
            // Re-render all tasks to reflect new view mode
            renderAllTasks();
            
            // Update task counts
            updateTaskCounts();
        }
        
        function handleMoveTask(task) {
            // Determine target status based on current status
            let targetStatus;
            if (task.status === 'backlog' || task.status === 'BACKLOG') {
                targetStatus = 'pending'; // Move backlog to TODO (pending)
            } else {
                targetStatus = 'backlog'; // Move TODO to backlog
            }
            
            // Update task status via API
            updateTaskStatusOptimistic(task.id, targetStatus);
        }
        
        function handleDeleteTask(task) {
            showDeleteTaskModal(task);
        }
        
        function showDeleteTaskModal(task) {
            const modal = document.getElementById('deleteModal');
            const messageEl = document.getElementById('deleteModalMessage');
            
            if (!modal || !messageEl) return;
            
            deleteData = {
                type: 'task',
                id: task.id,
                name: task.name
            };
            
            messageEl.textContent = `Are you sure you want to delete the task "${task.name}"?`;
            modal.style.display = 'flex';
        }
        
        async function deleteTask(taskId) {
            try {
                const response = await fetch(`/api/tasks/${taskId}`, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                console.log('Task deleted:', result);
                
                // Remove task from local state and UI
                AppState.tasks.delete(taskId);
                const taskElement = document.getElementById(`task-${taskId}`);
                if (taskElement) {
                    taskElement.remove();
                }
                
                // Update task counts
                updateTaskCounts();
                
            } catch (error) {
                console.error('Error deleting task:', error);
                alert('Failed to delete task. Please try again.');
            }
        }
        
        function handleProjectChange(event) {
            const newProjectId = event.target.value || null;
            AppState.selectedProjectId = newProjectId;
            
            // Clear epic selection when project changes
            AppState.selectedEpicId = null;
            
            // Update UI
            populateEpicSelector();
            saveSelectionState();
            filterAndRenderTasks();
        }
        
        function handleEpicChange(event) {
            const newEpicId = event.target.value || null;
            AppState.selectedEpicId = newEpicId;
            
            saveSelectionState();
            updateDeleteButtonVisibility();
            filterAndRenderTasks();
        }
        
        function loadSelectionState() {
            try {
                const saved = localStorage.getItem('pmDashboard.selectedFilters');
                if (saved) {
                    const filters = JSON.parse(saved);
                    AppState.selectedProjectId = filters.projectId || null;
                    AppState.selectedEpicId = filters.epicId || null;
                }
            } catch (error) {
                console.warn('Failed to load saved filter selections:', error);
            }
        }
        
        function saveSelectionState() {
            try {
                const filters = {
                    projectId: AppState.selectedProjectId,
                    epicId: AppState.selectedEpicId
                };
                localStorage.setItem('pmDashboard.selectedFilters', JSON.stringify(filters));
            } catch (error) {
                console.warn('Failed to save filter selections:', error);
            }
        }
        
        function filterAndRenderTasks() {
            renderAllTasks();
            updateTaskCounts();
        }
        
        function getFilteredTasks() {
            let filteredTasks = Array.from(AppState.tasks.values());
            
            console.log('DEBUG: Filtering tasks...');
            console.log('DEBUG: selectedProjectId:', AppState.selectedProjectId, typeof AppState.selectedProjectId);
            console.log('DEBUG: selectedEpicId:', AppState.selectedEpicId, typeof AppState.selectedEpicId);
            console.log('DEBUG: All tasks:', filteredTasks.map(t => ({id: t.id, name: t.name, project_id: t.project_id, epic_id: t.epic_id})));
            
            // Filter by project first if selected
            if (AppState.selectedProjectId) {
                console.log('DEBUG: Filtering by project...');
                filteredTasks = filteredTasks.filter(task => {
                    const match = task.project_id == AppState.selectedProjectId;
                    console.log(`DEBUG: Task ${task.id} project_id=${task.project_id} (${typeof task.project_id}) == ${AppState.selectedProjectId} (${typeof AppState.selectedProjectId}) = ${match}`);
                    return match;
                });
                console.log('DEBUG: After project filter:', filteredTasks.length, 'tasks');
            }
            
            // Then filter by epic if selected (within the project scope)
            if (AppState.selectedEpicId) {
                console.log('DEBUG: Filtering by epic...');
                filteredTasks = filteredTasks.filter(task => {
                    const match = task.epic_id == AppState.selectedEpicId;
                    console.log(`DEBUG: Task ${task.id} epic_id=${task.epic_id} (${typeof task.epic_id}) == ${AppState.selectedEpicId} (${typeof AppState.selectedEpicId}) = ${match}`);
                    return match;
                });
                console.log('DEBUG: After epic filter:', filteredTasks.length, 'tasks');
            }
            
            console.log('DEBUG: Final filtered tasks:', filteredTasks.map(t => ({id: t.id, name: t.name})));
            return filteredTasks;
        }
        
        // #COMPLETION_DRIVE_STARTUP: Initialize application when DOM is ready
        // Pattern: Ensure DOM is fully loaded before initializing interactive elements
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeApp);
        } else {
            initializeApp();
        }
    </script>

    <!-- Delete Confirmation Modal -->
    <div id="deleteModal" class="modal-overlay" style="display: none;">
        <div class="delete-modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Confirm Deletion</h3>
                <button class="modal-close-btn" onclick="closeDeleteModal()">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>
            </div>
            <div class="modal-body">
                <div class="warning-icon">
                    <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="#dc2626" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>
                        <line x1="12" y1="9" x2="12" y2="13"></line>
                        <line x1="12" y1="17" x2="12.01" y2="17"></line>
                    </svg>
                </div>
                <div class="delete-modal-text">
                    <p id="deleteModalMessage" class="delete-message"></p>
                    <p class="cascade-warning">This action cannot be undone and will permanently delete all associated data.</p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn modal-btn-cancel" onclick="closeDeleteModal()">Cancel</button>
                <button id="confirmDeleteBtn" class="modal-btn modal-btn-danger" onclick="confirmDelete()">Delete</button>
            </div>
        </div>
    </div>

    <!-- Knowledge Management Modal -->
    <div id="knowledgeModal" class="knowledge-modal">
        <div class="knowledge-modal-content">
            <!-- Interactive Modal Header with Action Buttons -->
            <div class="modal-header">
                <div class="modal-header-left">
                    <h2 class="modal-title">Knowledge Management</h2>
                    <div class="context-indicator" id="knowledgeContextIndicator">Project Context</div>
                </div>
                <div class="modal-header-actions">
                    <button id="addKnowledgeBtn" class="action-btn add-btn" title="Add New Knowledge Item">
                        <svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                            <path d="M8 0a1 1 0 0 1 1 1v6h6a1 1 0 1 1 0 2H9v6a1 1 0 1 1-2 0V9H1a1 1 0 0 1 0-2h6V1a1 1 0 0 1 1-1z"/>
                        </svg>
                        Add New
                    </button>
                    <button id="saveKnowledgeBtn" class="action-btn save-btn" title="Save Changes" style="display: none;">
                        <svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                            <path d="M2 1a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H9.5a1 1 0 0 0-1 1v7.293l2.646-2.647a.5.5 0 0 1 .708.708l-3.5 3.5a.5.5 0 0 1-.708 0l-3.5-3.5a.5.5 0 1 1 .708-.708L8.5 8.293V2a2 2 0 0 1 2-2H14a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h2.5a.5.5 0 0 1 0 1H2z"/>
                        </svg>
                        Save
                    </button>
                    <button id="cancelKnowledgeBtn" class="action-btn cancel-btn" title="Cancel Changes" style="display: none;">
                        <svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                            <path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z"/>
                        </svg>
                        Cancel
                    </button>
                    <button id="knowledgeModalCloseBtn" class="modal-close-btn" aria-label="Close Knowledge Modal">&times;</button>
                </div>
            </div>
            
            <div class="knowledge-modal-body">
                <!-- Enhanced Search and Filter Bar -->
                <div class="knowledge-search-container">
                    <div class="search-input-wrapper">
                        <svg class="search-icon" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                            <path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"/>
                        </svg>
                        <input type="text" id="knowledgeSearchInput" placeholder="Search knowledge items..." class="search-input">
                        <button id="clearSearchBtn" class="clear-search-btn" title="Clear search" style="display: none;">
                            <svg width="14" height="14" fill="currentColor" viewBox="0 0 16 16">
                                <path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z"/>
                            </svg>
                        </button>
                    </div>
                    <select id="categoryFilter" class="category-filter">
                        <option value="">All Categories</option>
                        <option value="Technical Documentation">Technical Documentation</option>
                        <option value="Best Practices">Best Practices</option>
                        <option value="Development Workflow">Development Workflow</option>
                        <option value="Troubleshooting">Troubleshooting</option>
                        <option value="Architecture">Architecture</option>
                        <option value="Standards">Standards</option>
                    </select>
                </div>
                
                <!-- Add/Edit Form (hidden by default) -->
                <div id="knowledgeEditForm" class="knowledge-edit-form" style="display: none;">
                    <div class="form-header">
                        <h3 id="formTitle">Add New Knowledge Item</h3>
                    </div>
                    <div class="form-grid">
                        <div class="form-group">
                            <label for="itemTitle">Title *</label>
                            <input type="text" id="itemTitle" class="form-input" required maxlength="200">
                            <span class="field-error" id="titleError"></span>
                        </div>
                        <div class="form-group">
                            <label for="itemCategory">Category *</label>
                            <select id="itemCategory" class="form-select" required>
                                <option value="">Select Category</option>
                                <option value="Technical Documentation">Technical Documentation</option>
                                <option value="Best Practices">Best Practices</option>
                                <option value="Development Workflow">Development Workflow</option>
                                <option value="Troubleshooting">Troubleshooting</option>
                                <option value="Architecture">Architecture</option>
                                <option value="Standards">Standards</option>
                            </select>
                            <span class="field-error" id="categoryError"></span>
                        </div>
                        <div class="form-group full-width">
                            <label for="itemContent">Description/Content *</label>
                            <textarea id="itemContent" class="form-textarea" required rows="4" maxlength="2000" placeholder="Provide detailed description or content..."></textarea>
                            <div class="textarea-footer">
                                <span class="field-error" id="contentError"></span>
                                <span class="char-counter" id="contentCharCounter">0/2000</span>
                            </div>
                        </div>
                        <div class="form-group full-width">
                            <label for="itemTags">Tags</label>
                            <div class="tags-input-container">
                                <input type="text" id="itemTags" class="form-input" placeholder="Enter tags (press Enter to add)">
                                <div class="tags-display" id="tagsDisplay"></div>
                            </div>
                            <small class="field-help">Press Enter after typing each tag</small>
                        </div>
                        <div class="form-group">
                            <label for="itemPriority">Priority</label>
                            <select id="itemPriority" class="form-select">
                                <option value="1">Low</option>
                                <option value="2" selected>Medium</option>
                                <option value="3">High</option>
                                <option value="4">Critical</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <!-- Loading State -->
                <div id="loadingState" class="loading-state" style="display: none;">
                    <div class="loading-spinner"></div>
                    <p>Loading knowledge items...</p>
                </div>
                
                <!-- Knowledge Items Container -->
                <div id="knowledgeItemsContainer" class="knowledge-items-container">
                    <!-- Dynamic content will be rendered here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Assumption Insights Modal -->
    <div id="assumption-insights-modal" class="assumption-insights-modal" style="display: none;">
        <div class="assumption-insights-modal-content">
            <div class="assumption-modal-header">
                <div>
                    <h2 class="assumption-modal-title">Assumption Insights Dashboard</h2>
                    <p class="assumption-modal-subtitle">Track and validate RA tag assumptions across projects</p>
                </div>
                <button id="assumptionModalCloseBtn" class="modal-close-btn" aria-label="Close Assumption Insights Modal">&times;</button>
            </div>
            
            <div class="assumption-modal-body">
                <!-- Filter Section -->
                <div class="assumption-filters-section">
                    <div class="assumption-filter-group">
                        <label for="assumption-project-select" class="assumption-filter-label">Project</label>
                        <select id="assumption-project-select" class="assumption-filter-select">
                            <option value="">All Projects</option>
                            <!-- Dynamic options will be populated here -->
                        </select>
                    </div>
                    <div class="assumption-filter-group">
                        <label for="assumption-epic-select" class="assumption-filter-label">Epic</label>
                        <select id="assumption-epic-select" class="assumption-filter-select">
                            <option value="">All Epics</option>
                            <!-- Dynamic options will be populated here -->
                        </select>
                    </div>
                    <div class="assumption-filter-group">
                        <label class="assumption-filter-label">Date Range</label>
                        <div class="date-range-inputs">
                            <input type="date" id="assumption-start-date" class="date-input" title="Start Date">
                            <input type="date" id="assumption-end-date" class="date-input" title="End Date">
                        </div>
                    </div>
                </div>
                
                <!-- KPI Cards Section -->
                <div class="assumption-kpi-cards">
                    <div class="assumption-kpi-card">
                        <div class="kpi-card-header">
                            <div class="kpi-card-icon success">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="20,6 9,17 4,12"></polyline>
                                </svg>
                            </div>
                            <p class="kpi-card-title">Success Rate</p>
                        </div>
                        <div class="kpi-card-value" id="success-rate-value">--</div>
                        <p class="kpi-card-subtitle" id="success-rate-subtitle">Loading...</p>
                    </div>
                    
                    <div class="assumption-kpi-card">
                        <div class="kpi-card-header">
                            <div class="kpi-card-icon total">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                                    <line x1="16" y1="2" x2="16" y2="6"></line>
                                    <line x1="8" y1="2" x2="8" y2="6"></line>
                                    <line x1="3" y1="10" x2="21" y2="10"></line>
                                </svg>
                            </div>
                            <p class="kpi-card-title">Total Validations</p>
                        </div>
                        <div class="kpi-card-value" id="total-validations-value">--</div>
                        <p class="kpi-card-subtitle" id="total-validations-subtitle">Loading...</p>
                    </div>
                    
                    <div class="assumption-kpi-card">
                        <div class="kpi-card-header">
                            <div class="kpi-card-icon partial">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <path d="M12 6v6l4 2"></path>
                                </svg>
                            </div>
                            <p class="kpi-card-title">Partial Validations</p>
                        </div>
                        <div class="kpi-card-value" id="partial-validations-value">--</div>
                        <p class="kpi-card-subtitle" id="partial-validations-subtitle">Loading...</p>
                    </div>
                </div>
                
                <!-- Top Risks Table -->
                <div class="assumption-data-section">
                    <div class="data-section-header">
                        <h3 class="data-section-title">Top Risks (Lowest Success Rates)</h3>
                    </div>
                    <div class="assumption-loading" id="top-risks-loading" style="display: none;">
                        <div class="spinner"></div>
                        <span>Loading top risks...</span>
                    </div>
                    <table class="assumption-data-table" id="top-risks-table">
                        <thead>
                            <tr>
                                <th>Tag Type</th>
                                <th>Success Rate</th>
                                <th>Validations (V/R/P)</th>
                                <th>Last Seen</th>
                            </tr>
                        </thead>
                        <tbody id="top-risks-tbody">
                            <!-- Dynamic content will be populated here -->
                        </tbody>
                    </table>
                    <div class="assumption-empty-state" id="top-risks-empty" style="display: none;">
                        <svg class="empty-state-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="10"></circle>
                            <path d="M12 6v6l4 2"></path>
                        </svg>
                        <h4 class="empty-state-title">No Risk Data Available</h4>
                        <p class="empty-state-message">Start using RA tags in your tasks to see assumption insights here.</p>
                    </div>
                </div>
                
                <!-- Recent Validations Table -->
                <div class="assumption-data-section">
                    <div class="data-section-header">
                        <h3 class="data-section-title">Recent Validations</h3>
                    </div>
                    <div class="assumption-loading" id="recent-validations-loading" style="display: none;">
                        <div class="spinner"></div>
                        <span>Loading recent validations...</span>
                    </div>
                    <table class="assumption-data-table" id="recent-validations-table">
                        <thead>
                            <tr>
                                <th>Time</th>
                                <th>Tag Type</th>
                                <th>Outcome</th>
                                <th>Reason</th>
                                <th>Task</th>
                            </tr>
                        </thead>
                        <tbody id="recent-validations-tbody">
                            <!-- Dynamic content will be populated here -->
                        </tbody>
                    </table>
                    <div class="assumption-empty-state" id="recent-validations-empty" style="display: none;">
                        <svg class="empty-state-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                            <line x1="16" y1="2" x2="16" y2="6"></line>
                            <line x1="8" y1="2" x2="8" y2="6"></line>
                            <line x1="3" y1="10" x2="21" y2="10"></line>
                        </svg>
                        <h4 class="empty-state-title">No Validations Yet</h4>
                        <p class="empty-state-message">Complete tasks with RA tags and capture validation results during review phase.</p>
                    </div>
                </div>
                
                <!-- Global Loading State -->
                <div class="assumption-loading" id="assumption-global-loading">
                    <div class="spinner"></div>
                    <span>Loading assumption insights...</span>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Assumption Detail Drawer -->
    <div id="assumption-detail-drawer" class="assumption-detail-drawer">
        <div class="drawer-header">
            <h3 class="drawer-title" id="drawer-tag-title">Tag Details</h3>
            <p class="drawer-subtitle" id="drawer-tag-subtitle">Historical validation data</p>
            <button id="drawerCloseBtn" class="drawer-close-btn" aria-label="Close Detail Drawer">&times;</button>
        </div>
        <div class="drawer-body">
            <div class="drawer-section">
                <h4 class="drawer-section-title">Success Metrics</h4>
                <div id="drawer-metrics-content">
                    <!-- Dynamic metrics content -->
                </div>
            </div>
            
            <div class="drawer-section">
                <h4 class="drawer-section-title">Validation History</h4>
                <div id="drawer-history-content">
                    <!-- Dynamic validation history -->
                </div>
            </div>
            
            <div class="drawer-section">
                <h4 class="drawer-section-title">Common Reasons</h4>
                <div id="drawer-reasons-content">
                    <!-- Dynamic common validation reasons -->
                </div>
            </div>
        </div>
    </div>

    <!-- Confirmation Dialog -->
    <div id="confirmationDialog" class="confirmation-dialog" style="display: none;">
        <div class="confirmation-content">
            <div class="confirmation-title" id="confirmationTitle">Confirm Action</div>
            <div class="confirmation-message" id="confirmationMessage">Are you sure you want to perform this action?</div>
            <div class="confirmation-actions">
                <button id="confirmationCancelBtn" class="cancel-confirm-btn">Cancel</button>
                <button id="confirmationConfirmBtn" class="confirm-btn">Confirm</button>
            </div>
        </div>
    </div>
</body>
</html>
