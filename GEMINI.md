# Gemini Project Analysis: project-manager-mcp

This document provides a summary of the `project-manager-mcp` project, generated by Gemini.

## Project Overview

This project is a sophisticated, Python-based project management system designed for AI-driven software development workflows. It is named `project-manager-mcp`, where "MCP" stands for **Model Context Protocol**. The system provides a set of tools, including a web interface and a CLI, to manage development tasks, epics, and projects.

A core feature is its "Response Aware" (RA) methodology, which enables Large Language Models (LLMs) to tag parts of their work where they are uncertain. These "RA tags" allow for targeted human validation, improving the reliability of AI-generated code and content.

## Technology Stack

*   **Backend:**
    *   **Framework:** FastAPI
    *   **Runtime:** Python 3.9+
    *   **Server:** Uvicorn (ASGI)
    *   **Real-time Communication:** WebSockets for the Model Context Protocol (MCP).
    *   **Database:** SQLite (as indicated in the project description).
    *   **CLI:** Click
    *   **Data Validation:** Pydantic
*   **Frontend:**
    *   **JavaScript:** Vanilla JavaScript
    *   **Styling:** Standard CSS, organized by component (Kanban, modals, forms).
*   **Tooling:**
    *   **Package Management:** Hatchling
    *   **Testing:** Pytest (with pytest-asyncio, pytest-cov, pytest-benchmark).
    *   **Code Quality:** Black, Ruff, and MyPy for formatting, linting, and static type checking.
    *   **Containerization:** Docker (`Dockerfile`, `docker-compose.yml`).

## Architecture

The project is a monorepo with a clear `src-layout` structure.

*   **`src/task_manager/`**: The core Python application package.
    *   **`mcp_server.py`**: The main FastAPI application, serving the backend API and handling MCP WebSocket connections.
    *   **`cli.py`**: The entry point for the command-line interface, built with Click.
    *   **`database.py`**: Manages the SQLite database connection and data access logic.
    *   **`ra_*.py` (e.g., `ra_tag_utils.py`, `ra_instructions.py`)**: Modules dedicated to the "Response Aware" (RA) functionality.
    *   **`static/`**: Contains the frontend web application assets, including HTML, CSS, and JavaScript for the UI, which features a Kanban board, planning views, and modals.
*   **`test/`**: A comprehensive test suite with unit and integration tests.
*   **`docs/` & `ra-docs/`**: Project and RA-specific documentation.
*   **`deploy/`**: Contains Docker and environment configuration for deployment.
*   **`pyproject.toml`**: The central configuration file defining dependencies, project metadata, and tool settings.

## Key Functionality

*   **Task Management:** Full CRUD (Create, Read, Update, Delete) operations for projects, epics, and tasks.
*   **AI-Driven Workflow:**
    *   **Model Context Protocol (MCP):** A WebSocket-based protocol for agents/models to interact with the project state.
    *   **Response Aware (RA) Tagging:** Allows models to flag uncertainties in their work for human review.
*   **Web Interface:** A user-facing frontend with a Kanban board, task planning views, and interactive modals.
*   **Command-Line Interface:** A powerful CLI (`pm-mcp`) for interacting with the system from the terminal.
*   **File System Monitoring:** Uses `watchdog` for live updates in planning mode.

## The Response Aware (RA) Methodology: A Deep Dive

The RA methodology is a systematic process for AI agents to identify, document, and flag uncertainties or assumptions they make while performing development tasks. It makes the AI's implicit assumptions explicit, creating a clear audit trail for human review.

### Core Component: The RA Tag

The central artifact is the **RA Tag**, a structured piece of metadata attached to a task.

*   **Format:** Tags follow a simple `#CATEGORY: Description` format.
*   **Key Categories:**
    *   `#COMPLETION_DRIVE_IMPL`: An assumption made during implementation (e.g., about how a library works).
    *   `#COMPLETION_DRIVE_INTEGRATION`: An assumption about how the code will integrate with another system.
    *   `#CONTEXT_RECONSTRUCT`: Used when the agent has to fill in gaps because the provided context was incomplete.
    *   `#SUGGEST_*` (e.g., `#SUGGEST_ERROR_HANDLING`): A proactive suggestion for an improvement that wasn't in the original request.
    *   `#PATTERN_MOMENTUM`: The agent is flagging that it's following a design pattern it observed elsewhere in the codebase.

### "Zero-Effort" Context Capture

A key feature is the ability to automatically capture rich context with every tag, including:

*   **Code Location:** File path and line number.
*   **Code Symbol:** The function or class name where the tag was created.
*   **Version Control State:** The current Git branch and commit hash for perfect traceability.
*   **Environment:** The programming language and a snippet of the relevant code.
*   **Attribution:** The agent ID and a timestamp.

### Modes and Scoring

The RA methodology includes parameters to adjust the level of detail and scrutiny:

*   **RA Modes:** Different modes like `simple`, `standard`, `ra-light`, and `ra-full` can be set for a task to dictate the expected thoroughness of RA tagging.
*   **Complexity Score:** A score from 1-10 can be assigned to a task to indicate its complexity, helping agents adjust their approach.

### End-to-End Workflow

1.  **Creation:** An agent encounters an uncertainty and uses a tool (e.g., `add_ra_tag`) to create a tag describing the assumption.
2.  **Enrichment:** The system automatically captures the git, file, and symbol context and attaches it to the tag.
3.  **Storage & Display:** The tag and its context are saved, linked to the task, and displayed in the UI.
4.  **Review & Verification:** A human developer reviews the tags and the explicit "Verification Needed" steps associated with them.
5.  **Validation:** The reviewer validates or rejects the assumption, and this action is formally captured to close the loop.

### Benefits

*   **Makes Assumptions Explicit:** Turns the AI's internal "best guesses" into a transparent, auditable log.
*   **Improves Reliability:** Focuses human review efforts on the exact points of uncertainty.
*   **Enhances Traceability:** With full Git and code context, you can trace an assumption back to the exact state of the codebase when it was made.

## Agent Workflow

This project defines a clear, mandatory workflow for all interacting agents to ensure safe and effective collaboration.

### Start With A Task (Required)

Before performing any work, an agent **must** create or select a task. This ensures that all actions, logs, and RA tags are associated with a specific work item, enabling proper ownership, status tracking, and locking.

### The Agent Loop

Once a task is established, agents should follow this loop:

1.  **Discover:** Find available work using tools like `get_available_tasks`.
2.  **Lock:** Claim exclusive access to a task with `acquire_task_lock` to prevent conflicts.
3.  **Work:** Perform the task in small, verifiable increments.
4.  **Tag:** Create RA tags for any assumptions or uncertainties using `add_ra_tag`.
5.  **Update:** Report progress with `update_task_status`.
6.  **Release:** Release the lock upon completion by moving the task to a final state (e.g., `DONE`) or using `release_task_lock`.

## Development Workflow

*   **Setup:** Create a Python virtual environment and install dependencies using `pip install -e .[dev]`.
*   **Running the Backend:** The application can be run locally using an ASGI server like Uvicorn. For example: `uvicorn src.task_manager.mcp_server:app --reload`.
*   **Running the CLI:** The CLI is available as `project-manager-mcp` after installation.
*   **Testing:** Run the test suite with the `pytest` command.
*   **Linting/Formatting:** Use `black`, `ruff`, and `mypy` to maintain code quality.
